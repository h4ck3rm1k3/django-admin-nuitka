// Generated code for Python source for module 'django.db.backends'
// created by Nuitka version 0.4.4pre3

// This code is in part copyright 2013 Kay Hayen.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "nuitka/prelude.hpp"

#include "__modules.hpp"
#include "__constants.hpp"
#include "__helpers.hpp"

// The _module_django__db__backends is a Python object pointer of module type.

// Note: For full compatability with CPython, every module variable access
// needs to go through it except for cases where the module cannot possibly
// have changed in the mean time.

PyObject *_module_django__db__backends;
PyDictObject *_moduledict_django__db__backends;

// The module level variables.
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_DEFAULT_DB_ALIAS( &_module_django__db__backends, &_python_str_plain_DEFAULT_DB_ALIAS );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_DatabaseError( &_module_django__db__backends, &_python_str_plain_DatabaseError );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_DatabaseErrorWrapper( &_module_django__db__backends, &_python_str_plain_DatabaseErrorWrapper );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_TransactionManagementError( &_module_django__db__backends, &_python_str_plain_TransactionManagementError );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends___metaclass__( &_module_django__db__backends, &_python_str_plain___metaclass__ );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_cached_property( &_module_django__db__backends, &_python_str_plain_cached_property );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_connection_created( &_module_django__db__backends, &_python_str_plain_connection_created );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_contextmanager( &_module_django__db__backends, &_python_str_plain_contextmanager );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_datetime( &_module_django__db__backends, &_python_str_plain_datetime );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_import_module( &_module_django__db__backends, &_python_str_plain_import_module );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_namedtuple( &_module_django__db__backends, &_python_str_plain_namedtuple );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_settings( &_module_django__db__backends, &_python_str_plain_settings );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_six( &_module_django__db__backends, &_python_str_plain_six );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_thread( &_module_django__db__backends, &_python_str_plain_thread );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_time( &_module_django__db__backends, &_python_str_plain_time );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_timezone( &_module_django__db__backends, &_python_str_plain_timezone );
static PyObjectGlobalVariable_django__db__backends _mvar_django__db__backends_util( &_module_django__db__backends, &_python_str_plain_util );

// The module function declarations.
NUITKA_LOCAL_MODULE PyObject *impl_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


NUITKA_LOCAL_MODULE PyObject *impl_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  );


NUITKA_LOCAL_MODULE PyObject *impl_class_1_StdDevPop_of_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  );


NUITKA_LOCAL_MODULE PyObject *impl_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


NUITKA_LOCAL_MODULE PyObject *impl_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( PyObject *_python_par___iterator, PyObjectSharedLocalVariable &python_closure_to_unicode );


NUITKA_LOCAL_MODULE PyObject *impl_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( PyObject *_python_par___iterator, PyObjectSharedLocalVariable &python_closure_to_unicode );


NUITKA_LOCAL_MODULE PyObject *impl_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


NUITKA_LOCAL_MODULE PyObject *impl_listcontr_1_of_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( PyObject *_python_par___iterator, PyObjectLocalVariable &python_closure_f );


NUITKA_LOCAL_MODULE PyObject *impl_listcontr_2_of_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( PyObject *_python_par___iterator, PyObjectLocalVariable &python_closure_existing_tables, PyObjectLocalParameterVariableNoDel &python_closure_self, PyObjectLocalVariable &python_closure_t );


NUITKA_LOCAL_MODULE PyObject *impl_listcontr_1_of_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( PyObject *_python_par___iterator, PyObjectLocalVariable &python_closure_m, PyObjectLocalParameterVariableNoDel &python_closure_self, PyObjectLocalParameterVariableNoDel &python_closure_tables );


NUITKA_LOCAL_MODULE PyObject *impl_class_5_BaseDatabaseClient_of_module_django__db__backends(  );


NUITKA_LOCAL_MODULE PyObject *impl_class_6_BaseDatabaseValidation_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  );


static PyObject *MAKE_FUNCTION_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( PyObjectSharedLocalVariable &python_closure_force_text );


// This structure is for attachment as self of lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends.
// It is allocated at the time the function object is created.
struct _context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t
{
    // The function can access a read-only closure of the creator.
    PyObjectClosureVariable python_closure_force_text;
};

static void _context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_destructor( void *context_voidptr )
{
    _context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = (_context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *)context_voidptr;



    delete _python_context;
}


// The module function definitions.
NUITKA_LOCAL_MODULE PyObject *impl_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalVariable _python_var___module__( _python_str_plain___module__ );
    PyObjectLocalVariable _python_var___doc__( _python_str_plain___doc__ );
    PyObjectLocalVariable _python_var_ops( _python_str_plain_ops );
    PyObjectLocalVariable _python_var_vendor( _python_str_plain_vendor );
    PyObjectLocalVariable _python_var___init__( _python_str_plain___init__ );
    PyObjectLocalVariable _python_var___eq__( _python_str_plain___eq__ );
    PyObjectLocalVariable _python_var___ne__( _python_str_plain___ne__ );
    PyObjectLocalVariable _python_var___hash__( _python_str_plain___hash__ );
    PyObjectLocalVariable _python_var_get_connection_params( _python_str_plain_get_connection_params );
    PyObjectLocalVariable _python_var_get_new_connection( _python_str_plain_get_new_connection );
    PyObjectLocalVariable _python_var_init_connection_state( _python_str_plain_init_connection_state );
    PyObjectLocalVariable _python_var_create_cursor( _python_str_plain_create_cursor );
    PyObjectLocalVariable _python_var_connect( _python_str_plain_connect );
    PyObjectLocalVariable _python_var_ensure_connection( _python_str_plain_ensure_connection );
    PyObjectLocalVariable _python_var__cursor( _python_str_plain__cursor );
    PyObjectLocalVariable _python_var__commit( _python_str_plain__commit );
    PyObjectLocalVariable _python_var__rollback( _python_str_plain__rollback );
    PyObjectLocalVariable _python_var__close( _python_str_plain__close );
    PyObjectLocalVariable _python_var_cursor( _python_str_plain_cursor );
    PyObjectLocalVariable _python_var_commit( _python_str_plain_commit );
    PyObjectLocalVariable _python_var_rollback( _python_str_plain_rollback );
    PyObjectLocalVariable _python_var_close( _python_str_plain_close );
    PyObjectLocalVariable _python_var__savepoint( _python_str_plain__savepoint );
    PyObjectLocalVariable _python_var__savepoint_rollback( _python_str_plain__savepoint_rollback );
    PyObjectLocalVariable _python_var__savepoint_commit( _python_str_plain__savepoint_commit );
    PyObjectLocalVariable _python_var__savepoint_allowed( _python_str_plain__savepoint_allowed );
    PyObjectLocalVariable _python_var_savepoint( _python_str_plain_savepoint );
    PyObjectLocalVariable _python_var_savepoint_rollback( _python_str_plain_savepoint_rollback );
    PyObjectLocalVariable _python_var_savepoint_commit( _python_str_plain_savepoint_commit );
    PyObjectLocalVariable _python_var_clean_savepoints( _python_str_plain_clean_savepoints );
    PyObjectLocalVariable _python_var__set_autocommit( _python_str_plain__set_autocommit );
    PyObjectLocalVariable _python_var_enter_transaction_management( _python_str_plain_enter_transaction_management );
    PyObjectLocalVariable _python_var_leave_transaction_management( _python_str_plain_leave_transaction_management );
    PyObjectLocalVariable _python_var_set_autocommit( _python_str_plain_set_autocommit );
    PyObjectLocalVariable _python_var_validate_no_atomic_block( _python_str_plain_validate_no_atomic_block );
    PyObjectLocalVariable _python_var_abort( _python_str_plain_abort );
    PyObjectLocalVariable _python_var_is_dirty( _python_str_plain_is_dirty );
    PyObjectLocalVariable _python_var_set_dirty( _python_str_plain_set_dirty );
    PyObjectLocalVariable _python_var_set_clean( _python_str_plain_set_clean );
    PyObjectLocalVariable _python_var_constraint_checks_disabled( _python_str_plain_constraint_checks_disabled );
    PyObjectLocalVariable _python_var_disable_constraint_checking( _python_str_plain_disable_constraint_checking );
    PyObjectLocalVariable _python_var_enable_constraint_checking( _python_str_plain_enable_constraint_checking );
    PyObjectLocalVariable _python_var_check_constraints( _python_str_plain_check_constraints );
    PyObjectLocalVariable _python_var_is_usable( _python_str_plain_is_usable );
    PyObjectLocalVariable _python_var_close_if_unusable_or_obsolete( _python_str_plain_close_if_unusable_or_obsolete );
    PyObjectLocalVariable _python_var_validate_thread_sharing( _python_str_plain_validate_thread_sharing );
    PyObjectLocalVariable _python_var_wrap_database_errors( _python_str_plain_wrap_database_errors );
    PyObjectLocalVariable _python_var_make_debug_cursor( _python_str_plain_make_debug_cursor );
    PyObjectLocalVariable _python_var_temporary_connection( _python_str_plain_temporary_connection );
    PyObjectLocalVariable _python_var__start_transaction_under_autocommit( _python_str_plain__start_transaction_under_autocommit );

    // Actual function code.
    _python_var___module__.assign0( _python_str_plain_backends );
    _python_var___doc__.assign0( _python_str_digest_f69b5f3f0f901b49db39cdc07e6f3af5 );
    _python_var_ops.assign0( Py_None );
    _python_var_vendor.assign0( _python_str_plain_unknown );
    static PyFrameObject *frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_7e3351edb9d5ac9842903d6e68d85f99, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 32 );
        _python_var___init__.assign1( MAKE_FUNCTION_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( MAKE_TUPLE2( _mvar_django__db__backends_DEFAULT_DB_ALIAS.asObject0(), Py_False ) ) );
        _python_var___eq__.assign1( MAKE_FUNCTION_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var___ne__.assign1( MAKE_FUNCTION_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var___hash__.assign1( MAKE_FUNCTION_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_get_connection_params.assign1( MAKE_FUNCTION_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_get_new_connection.assign1( MAKE_FUNCTION_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_init_connection_state.assign1( MAKE_FUNCTION_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_create_cursor.assign1( MAKE_FUNCTION_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_connect.assign1( MAKE_FUNCTION_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_ensure_connection.assign1( MAKE_FUNCTION_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__cursor.assign1( MAKE_FUNCTION_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__commit.assign1( MAKE_FUNCTION_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__rollback.assign1( MAKE_FUNCTION_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__close.assign1( MAKE_FUNCTION_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_cursor.assign1( MAKE_FUNCTION_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_commit.assign1( MAKE_FUNCTION_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_rollback.assign1( MAKE_FUNCTION_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_close.assign1( MAKE_FUNCTION_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__savepoint.assign1( MAKE_FUNCTION_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__savepoint_rollback.assign1( MAKE_FUNCTION_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__savepoint_commit.assign1( MAKE_FUNCTION_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__savepoint_allowed.assign1( MAKE_FUNCTION_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_savepoint.assign1( MAKE_FUNCTION_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_savepoint_rollback.assign1( MAKE_FUNCTION_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_savepoint_commit.assign1( MAKE_FUNCTION_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_clean_savepoints.assign1( MAKE_FUNCTION_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var__set_autocommit.assign1( MAKE_FUNCTION_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_enter_transaction_management.assign1( MAKE_FUNCTION_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_leave_transaction_management.assign1( MAKE_FUNCTION_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_set_autocommit.assign1( MAKE_FUNCTION_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_validate_no_atomic_block.assign1( MAKE_FUNCTION_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_abort.assign1( MAKE_FUNCTION_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_is_dirty.assign1( MAKE_FUNCTION_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_set_dirty.assign1( MAKE_FUNCTION_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_set_clean.assign1( MAKE_FUNCTION_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        frame_guard.setLineNumber( 378 );
        _python_var_constraint_checks_disabled.assign1( CALL_FUNCTION_WITH_ARGS( _mvar_django__db__backends_contextmanager.asObject0(), PyObjectTemporary( MAKE_FUNCTION_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) ).asObject() ) );
        _python_var_disable_constraint_checking.assign1( MAKE_FUNCTION_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_enable_constraint_checking.assign1( MAKE_FUNCTION_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_check_constraints.assign1( MAKE_FUNCTION_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_is_usable.assign1( MAKE_FUNCTION_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_close_if_unusable_or_obsolete.assign1( MAKE_FUNCTION_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_validate_thread_sharing.assign1( MAKE_FUNCTION_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_wrap_database_errors.assign1( MAKE_FUNCTION_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        _python_var_make_debug_cursor.assign1( MAKE_FUNCTION_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
        frame_guard.setLineNumber( 477 );
        _python_var_temporary_connection.assign1( CALL_FUNCTION_WITH_ARGS( _mvar_django__db__backends_contextmanager.asObject0(), PyObjectTemporary( MAKE_FUNCTION_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) ).asObject() ) );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var__start_transaction_under_autocommit.updateLocalsDict( _python_var_temporary_connection.updateLocalsDict( _python_var_make_debug_cursor.updateLocalsDict( _python_var_wrap_database_errors.updateLocalsDict( _python_var_validate_thread_sharing.updateLocalsDict( _python_var_close_if_unusable_or_obsolete.updateLocalsDict( _python_var_is_usable.updateLocalsDict( _python_var_check_constraints.updateLocalsDict( _python_var_enable_constraint_checking.updateLocalsDict( _python_var_disable_constraint_checking.updateLocalsDict( _python_var_constraint_checks_disabled.updateLocalsDict( _python_var_set_clean.updateLocalsDict( _python_var_set_dirty.updateLocalsDict( _python_var_is_dirty.updateLocalsDict( _python_var_abort.updateLocalsDict( _python_var_validate_no_atomic_block.updateLocalsDict( _python_var_set_autocommit.updateLocalsDict( _python_var_leave_transaction_management.updateLocalsDict( _python_var_enter_transaction_management.updateLocalsDict( _python_var__set_autocommit.updateLocalsDict( _python_var_clean_savepoints.updateLocalsDict( _python_var_savepoint_commit.updateLocalsDict( _python_var_savepoint_rollback.updateLocalsDict( _python_var_savepoint.updateLocalsDict( _python_var__savepoint_allowed.updateLocalsDict( _python_var__savepoint_commit.updateLocalsDict( _python_var__savepoint_rollback.updateLocalsDict( _python_var__savepoint.updateLocalsDict( _python_var_close.updateLocalsDict( _python_var_rollback.updateLocalsDict( _python_var_commit.updateLocalsDict( _python_var_cursor.updateLocalsDict( _python_var__close.updateLocalsDict( _python_var__rollback.updateLocalsDict( _python_var__commit.updateLocalsDict( _python_var__cursor.updateLocalsDict( _python_var_ensure_connection.updateLocalsDict( _python_var_connect.updateLocalsDict( _python_var_create_cursor.updateLocalsDict( _python_var_init_connection_state.updateLocalsDict( _python_var_get_new_connection.updateLocalsDict( _python_var_get_connection_params.updateLocalsDict( _python_var___hash__.updateLocalsDict( _python_var___ne__.updateLocalsDict( _python_var___eq__.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var_vendor.updateLocalsDict( _python_var_ops.updateLocalsDict( _python_var___doc__.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        throw;
    }
    _python_var__start_transaction_under_autocommit.assign1( MAKE_FUNCTION_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
    return _python_var__start_transaction_under_autocommit.updateLocalsDict( _python_var_temporary_connection.updateLocalsDict( _python_var_make_debug_cursor.updateLocalsDict( _python_var_wrap_database_errors.updateLocalsDict( _python_var_validate_thread_sharing.updateLocalsDict( _python_var_close_if_unusable_or_obsolete.updateLocalsDict( _python_var_is_usable.updateLocalsDict( _python_var_check_constraints.updateLocalsDict( _python_var_enable_constraint_checking.updateLocalsDict( _python_var_disable_constraint_checking.updateLocalsDict( _python_var_constraint_checks_disabled.updateLocalsDict( _python_var_set_clean.updateLocalsDict( _python_var_set_dirty.updateLocalsDict( _python_var_is_dirty.updateLocalsDict( _python_var_abort.updateLocalsDict( _python_var_validate_no_atomic_block.updateLocalsDict( _python_var_set_autocommit.updateLocalsDict( _python_var_leave_transaction_management.updateLocalsDict( _python_var_enter_transaction_management.updateLocalsDict( _python_var__set_autocommit.updateLocalsDict( _python_var_clean_savepoints.updateLocalsDict( _python_var_savepoint_commit.updateLocalsDict( _python_var_savepoint_rollback.updateLocalsDict( _python_var_savepoint.updateLocalsDict( _python_var__savepoint_allowed.updateLocalsDict( _python_var__savepoint_commit.updateLocalsDict( _python_var__savepoint_rollback.updateLocalsDict( _python_var__savepoint.updateLocalsDict( _python_var_close.updateLocalsDict( _python_var_rollback.updateLocalsDict( _python_var_commit.updateLocalsDict( _python_var_cursor.updateLocalsDict( _python_var__close.updateLocalsDict( _python_var__rollback.updateLocalsDict( _python_var__commit.updateLocalsDict( _python_var__cursor.updateLocalsDict( _python_var_ensure_connection.updateLocalsDict( _python_var_connect.updateLocalsDict( _python_var_create_cursor.updateLocalsDict( _python_var_init_connection_state.updateLocalsDict( _python_var_get_new_connection.updateLocalsDict( _python_var_get_connection_params.updateLocalsDict( _python_var___hash__.updateLocalsDict( _python_var___ne__.updateLocalsDict( _python_var___eq__.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var_vendor.updateLocalsDict( _python_var_ops.updateLocalsDict( _python_var___doc__.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) );
}


static PyObject *impl_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_settings_dict, PyObject *_python_par_alias, PyObject *_python_par_allow_thread_sharing )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_settings_dict( _python_str_plain_settings_dict, _python_par_settings_dict );
    PyObjectLocalParameterVariableNoDel _python_var_alias( _python_str_plain_alias, _python_par_alias );
    PyObjectLocalParameterVariableNoDel _python_var_allow_thread_sharing( _python_str_plain_allow_thread_sharing, _python_par_allow_thread_sharing );

    // Actual function code.
    static PyFrameObject *frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_bfe4a65ea4b8b62558a8c1f1cfeb19b3, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 37 );
        SET_ATTRIBUTE( Py_None, _python_var_self.asObject(), _python_str_plain_connection );
        frame_guard.setLineNumber( 38 );
        SET_ATTRIBUTE( PyObjectTemporary( PyList_New( 0 ) ).asObject(), _python_var_self.asObject(), _python_str_plain_queries );
        frame_guard.setLineNumber( 39 );
        {
                PyObject *tmp_identifier = _python_var_settings_dict.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_settings_dict );
        }
        frame_guard.setLineNumber( 40 );
        {
                PyObject *tmp_identifier = _python_var_alias.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_alias );
        }
        frame_guard.setLineNumber( 41 );
        SET_ATTRIBUTE( Py_None, _python_var_self.asObject(), _python_str_plain_use_debug_cursor );
        frame_guard.setLineNumber( 44 );
        SET_ATTRIBUTE( _python_int_0, _python_var_self.asObject(), _python_str_plain_savepoint_state );
        frame_guard.setLineNumber( 47 );
        SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain_autocommit );
        frame_guard.setLineNumber( 48 );
        SET_ATTRIBUTE( PyObjectTemporary( PyList_New( 0 ) ).asObject(), _python_var_self.asObject(), _python_str_plain_transaction_state );
        frame_guard.setLineNumber( 52 );
        SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain__dirty );
        frame_guard.setLineNumber( 54 );
        SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain_in_atomic_block );
        frame_guard.setLineNumber( 56 );
        SET_ATTRIBUTE( PyObjectTemporary( PyList_New( 0 ) ).asObject(), _python_var_self.asObject(), _python_str_plain_savepoint_ids );
        frame_guard.setLineNumber( 59 );
        SET_ATTRIBUTE( Py_True, _python_var_self.asObject(), _python_str_plain_commit_on_exit );
        frame_guard.setLineNumber( 62 );
        SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain_needs_rollback );
        frame_guard.setLineNumber( 65 );
        SET_ATTRIBUTE( Py_None, _python_var_self.asObject(), _python_str_plain_close_at );
        frame_guard.setLineNumber( 66 );
        SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain_errors_occurred );
        frame_guard.setLineNumber( 69 );
        {
                PyObject *tmp_identifier = _python_var_allow_thread_sharing.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_allow_thread_sharing );
        }
        frame_guard.setLineNumber( 70 );
        {
                PyObjectTemporary tmp_identifier( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_thread.asObject0(), _python_str_plain_get_ident ) ).asObject() ) );
                SET_ATTRIBUTE( tmp_identifier.asObject(), _python_var_self.asObject(), _python_str_plain__thread_ident );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_allow_thread_sharing.updateLocalsDict( _python_var_alias.updateLocalsDict( _python_var_settings_dict.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_settings_dict = NULL;
    PyObject *_python_par_alias = NULL;
    PyObject *_python_par_allow_thread_sharing = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__init__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_settings_dict == key )
            {
                if (unlikely( _python_par_settings_dict ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'settings_dict'" );
                    goto error_exit;
                }

                _python_par_settings_dict = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_alias == key )
            {
                if (unlikely( _python_par_alias ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'alias'" );
                    goto error_exit;
                }

                _python_par_alias = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_allow_thread_sharing == key )
            {
                if (unlikely( _python_par_allow_thread_sharing ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'allow_thread_sharing'" );
                    goto error_exit;
                }

                _python_par_allow_thread_sharing = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_settings_dict, key ) )
            {
                if (unlikely( _python_par_settings_dict ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'settings_dict'" );
                    goto error_exit;
                }

                _python_par_settings_dict = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_alias, key ) )
            {
                if (unlikely( _python_par_alias ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'alias'" );
                    goto error_exit;
                }

                _python_par_alias = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_allow_thread_sharing, key ) )
            {
                if (unlikely( _python_par_allow_thread_sharing ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'allow_thread_sharing'" );
                    goto error_exit;
                }

                _python_par_allow_thread_sharing = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__init__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 4 ))
    {
        if ( 4 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__init__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 4, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 4 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#else
            if ( 4 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes %d positional arguments but %zd were given", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 4 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d non-keyword arguments (%zd given)", 4, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 4 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 4 ? args_given : 4;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_settings_dict != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'settings_dict'" );
             goto error_exit;
         }

        _python_par_settings_dict = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_alias != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'alias'" );
             goto error_exit;
         }

        _python_par_alias = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_allow_thread_sharing != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'allow_thread_sharing'" );
             goto error_exit;
         }

        _python_par_allow_thread_sharing = INCREASE_REFCOUNT( args[ 3 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_alias == NULL )
    {
        _python_par_alias = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_alias );
    }
    if ( _python_par_allow_thread_sharing == NULL )
    {
        _python_par_allow_thread_sharing = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 1 ) );
        assertObject( _python_par_allow_thread_sharing );
    }


    return impl_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_settings_dict, _python_par_alias, _python_par_allow_thread_sharing );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_settings_dict );
    Py_XDECREF( _python_par_alias );
    Py_XDECREF( _python_par_allow_thread_sharing );

    return NULL;
}

static PyObject *dparse_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 4)
    {
        return impl_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_other )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_other( _python_str_plain_other, _python_par_other );

    // Actual function code.
    static PyFrameObject *frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_44831b8e2eac21cb1519f8e0f0588afe, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 73 );
        {
            PyObjectTempKeeper1 cmp1;
            return ( cmp1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_alias ) ), RICH_COMPARE_EQ( cmp1.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_other.asObject(), _python_str_plain_alias ) ).asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_other.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_other = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__eq__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__eq__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_other == key )
            {
                if (unlikely( _python_par_other ))
                {
                    PyErr_Format( PyExc_TypeError, "__eq__() got multiple values for keyword argument 'other'" );
                    goto error_exit;
                }

                _python_par_other = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__eq__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_other, key ) )
            {
                if (unlikely( _python_par_other ))
                {
                    PyErr_Format( PyExc_TypeError, "__eq__() got multiple values for keyword argument 'other'" );
                    goto error_exit;
                }

                _python_par_other = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__eq__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__eq__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__eq__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__eq__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__eq__() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__eq__() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__eq__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__eq__() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__eq__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__eq__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__eq__() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "__eq__() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__eq__() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__eq__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_other != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__eq__() got multiple values for keyword argument 'other'" );
             goto error_exit;
         }

        _python_par_other = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_other );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_other );

    return NULL;
}

static PyObject *dparse_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_other )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_other( _python_str_plain_other, _python_par_other );

    // Actual function code.
    static PyFrameObject *frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_3eaba9864b17af6a5b96bdcaf5895269, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 76 );
        {
            PyObjectTempKeeper0 cmp1;
            return INCREASE_REFCOUNT( UNARY_OPERATION( UNARY_NOT, PyObjectTemporary( ( cmp1.assign( _python_var_self.asObject() ), RICH_COMPARE_EQ( cmp1.asObject0(), _python_var_other.asObject() ) ) ).asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_other.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_other = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__ne__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__ne__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_other == key )
            {
                if (unlikely( _python_par_other ))
                {
                    PyErr_Format( PyExc_TypeError, "__ne__() got multiple values for keyword argument 'other'" );
                    goto error_exit;
                }

                _python_par_other = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__ne__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_other, key ) )
            {
                if (unlikely( _python_par_other ))
                {
                    PyErr_Format( PyExc_TypeError, "__ne__() got multiple values for keyword argument 'other'" );
                    goto error_exit;
                }

                _python_par_other = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__ne__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__ne__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__ne__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__ne__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__ne__() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__ne__() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__ne__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__ne__() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__ne__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__ne__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__ne__() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "__ne__() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__ne__() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__ne__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_other != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__ne__() got multiple values for keyword argument 'other'" );
             goto error_exit;
         }

        _python_par_other = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_other );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_other );

    return NULL;
}

static PyObject *dparse_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_92ff8da4debc05ba9f7e6fd46141cb66, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 79 );
        return CALL_FUNCTION_WITH_ARGS( LOOKUP_BUILTIN( _python_str_plain_hash ), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_alias ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__hash__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__hash__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__hash__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__hash__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__hash__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__hash__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__hash__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__hash__() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "__hash__() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__hash__() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "__hash__() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__hash__() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__hash__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__hash__() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "__hash__() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__hash__() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__hash__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_536fd37005ad9fe8f34cb0a5e7204ae4, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 85 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "get_connection_params() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_connection_params() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_connection_params() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "get_connection_params() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_connection_params() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "get_connection_params() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "get_connection_params() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_connection_params() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "get_connection_params() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_connection_params() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "get_connection_params() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_connection_params() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "get_connection_params() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "get_connection_params() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "get_connection_params() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "get_connection_params() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_connection_params() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_conn_params )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_conn_params( _python_str_plain_conn_params, _python_par_conn_params );

    // Actual function code.
    static PyFrameObject *frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_5b83f38c6e6c935b21b38ec6061eeb99, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 89 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_conn_params.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_conn_params = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "get_new_connection() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_new_connection() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_conn_params == key )
            {
                if (unlikely( _python_par_conn_params ))
                {
                    PyErr_Format( PyExc_TypeError, "get_new_connection() got multiple values for keyword argument 'conn_params'" );
                    goto error_exit;
                }

                _python_par_conn_params = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_new_connection() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_conn_params, key ) )
            {
                if (unlikely( _python_par_conn_params ))
                {
                    PyErr_Format( PyExc_TypeError, "get_new_connection() got multiple values for keyword argument 'conn_params'" );
                    goto error_exit;
                }

                _python_par_conn_params = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "get_new_connection() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_new_connection() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "get_new_connection() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "get_new_connection() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_new_connection() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "get_new_connection() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_new_connection() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "get_new_connection() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_new_connection() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "get_new_connection() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "get_new_connection() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "get_new_connection() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "get_new_connection() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_new_connection() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_conn_params != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_new_connection() got multiple values for keyword argument 'conn_params'" );
             goto error_exit;
         }

        _python_par_conn_params = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_conn_params );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_conn_params );

    return NULL;
}

static PyObject *dparse_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_a64ef9553db5b1a6addd0b8c96dd5d0d, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 93 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "init_connection_state() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "init_connection_state() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "init_connection_state() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "init_connection_state() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "init_connection_state() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "init_connection_state() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "init_connection_state() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "init_connection_state() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "init_connection_state() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "init_connection_state() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "init_connection_state() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "init_connection_state() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "init_connection_state() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "init_connection_state() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "init_connection_state() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "init_connection_state() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "init_connection_state() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_560bb2051560de40ae148c9c1556c32a, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 97 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "create_cursor() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "create_cursor() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "create_cursor() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "create_cursor() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "create_cursor() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "create_cursor() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "create_cursor() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "create_cursor() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "create_cursor() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "create_cursor() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "create_cursor() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "create_cursor() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "create_cursor() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "create_cursor() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "create_cursor() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "create_cursor() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "create_cursor() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalVariable _python_var_max_age( _python_str_plain_max_age );
    PyObjectLocalVariable _python_var_conn_params( _python_str_plain_conn_params );

    // Actual function code.
    static PyFrameObject *frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_53fd8ad664daa59fe1b5a5668630caa5, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 104 );
        SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain_in_atomic_block );
        frame_guard.setLineNumber( 105 );
        SET_ATTRIBUTE( PyObjectTemporary( PyList_New( 0 ) ).asObject(), _python_var_self.asObject(), _python_str_plain_savepoint_ids );
        frame_guard.setLineNumber( 107 );
        _python_var_max_age.assign1( LOOKUP_SUBSCRIPT( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_settings_dict ) ).asObject(), _python_str_plain_CONN_MAX_AGE ) );
        frame_guard.setLineNumber( 108 );
        {
            PyObjectTempKeeper1 op1;
            {
                PyObjectTemporary tmp_identifier( ( ( _python_var_max_age.asObject() == Py_None ) ? INCREASE_REFCOUNT( Py_None ) : ( op1.assign( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_time.asObject0(), _python_str_plain_time ) ).asObject() ) ), BINARY_OPERATION_ADD( op1.asObject0(), _python_var_max_age.asObject() ) ) ) );
                SET_ATTRIBUTE( tmp_identifier.asObject(), _python_var_self.asObject(), _python_str_plain_close_at );
        }
        }
        frame_guard.setLineNumber( 109 );
        SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain_errors_occurred );
        frame_guard.setLineNumber( 111 );
        _python_var_conn_params.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_get_connection_params ) ).asObject() ) );
        frame_guard.setLineNumber( 112 );
        {
            PyObjectTempKeeper1 call3;
            {
                PyObjectTemporary tmp_identifier( ( call3.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_get_new_connection ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), _python_var_conn_params.asObject() ) ) );
                SET_ATTRIBUTE( tmp_identifier.asObject(), _python_var_self.asObject(), _python_str_plain_connection );
        }
        }
        frame_guard.setLineNumber( 113 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_init_connection_state ) ).asObject() ) );
        frame_guard.setLineNumber( 114 );
        if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_SUBSCRIPT( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_settings_dict ) ).asObject(), _python_str_plain_AUTOCOMMIT ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 115 );
            DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_set_autocommit ) ).asObject(), Py_True ) );
        }
        frame_guard.setLineNumber( 116 );
        {
            PyObjectTempKeeper1 call9;
            PyObjectTempKeeper1 make_dict5;
            DECREASE_REFCOUNT( ( call9.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_connection_created.asObject0(), _python_str_plain_send ) ), CALL_FUNCTION( call9.asObject0(), _python_tuple_empty, PyObjectTemporary( ( make_dict5.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain___class__ ) ), MAKE_DICT2( make_dict5.asObject0(), _python_str_plain_sender, _python_var_self.asObject(), _python_str_plain_connection ) ) ).asObject() ) ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( _python_var_conn_params.updateLocalsDict( _python_var_max_age.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "connect() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "connect() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "connect() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "connect() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "connect() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "connect() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "connect() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "connect() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "connect() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "connect() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "connect() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "connect() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "connect() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "connect() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "connect() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "connect() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "connect() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_0ec3e7a604a102e6829567f33d26f2eb, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 122 );
        if ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject() == Py_None ) )
        {
            {
                frame_guard.setLineNumber( 123 );
                PyObjectTemporary _python_tmp_with_source( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_wrap_database_errors ) ).asObject() ) );
                PyObjectTemporary _python_tmp_with_exit( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___exit__ ) );
                PyObjectTemporary _python_tmp_with_enter( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___enter__ ) ).asObject() ) );
                PyObject *_python_tmp_indicator = Py_True;
                PythonExceptionKeeper _caught_1;


                try
                {
                    try
                    {
                        frame_guard.setLineNumber( 124 );
                        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connect ) ).asObject() ) );
                    }
                    catch ( PythonException &_exception )
                    {
                        if ( !_exception.hasTraceback() )
                        {
                            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                        }
                        else
                        {
                            _exception.addTraceback( frame_guard.getFrame0() );
                        }

                        frame_guard.preserveExistingException();

#if PYTHON_VERSION >= 300
                        ExceptionRestorerFrameGuard restorer( &frame_guard );
#endif
                        _exception.toExceptionHandler();

                        if ( _exception.matches( PyExc_BaseException ) )
                        {
                            frame_guard.detachFrame();
                            _python_tmp_indicator = Py_False;
                            if ( (!( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), _exception.getType(), _exception.getValue(), (PyObject *)_exception.getTraceback() ) ).asObject() ) )) )
                            {
                                {
                                    PyTracebackObject *tb = _exception.getTraceback();
                                    frame_guard.setLineNumber( tb->tb_lineno );
                                    _exception.setTraceback( tb->tb_next );
                                    tb->tb_next = NULL;

                                    throw;
                                }
                            }
                        }
                        else
                        {
                            PyTracebackObject *tb = _exception.getTraceback();
                            frame_guard.setLineNumber( tb->tb_lineno );
                            _exception.setTraceback( tb->tb_next );
                            tb->tb_next = NULL;

                            throw;
                        }
                    }
                }
                catch ( PythonException &_exception )
                {
                    if ( !_exception.hasTraceback() )
                    {
                        _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                    }
                    else
                    {
                        _exception.addTraceback( frame_guard.getFrame0() );
                    }

                    _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
                    frame_guard.preserveExistingException();

                    _exception.toExceptionHandler();
#endif
                }

                // Final code:
                if ( ( _python_tmp_indicator == Py_True ) )
                {
                    DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), Py_None, Py_None, Py_None ) );
                }
                _caught_1.rethrow();
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "ensure_connection() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "ensure_connection() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "ensure_connection() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "ensure_connection() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "ensure_connection() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "ensure_connection() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "ensure_connection() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "ensure_connection() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "ensure_connection() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "ensure_connection() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "ensure_connection() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "ensure_connection() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "ensure_connection() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "ensure_connection() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "ensure_connection() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "ensure_connection() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "ensure_connection() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_174058353f799e58cf8ca1b5f3ef9c68, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 129 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_ensure_connection ) ).asObject() ) );
        {
            frame_guard.setLineNumber( 130 );
            PyObjectTemporary _python_tmp_with_source( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_wrap_database_errors ) ).asObject() ) );
            PyObjectTemporary _python_tmp_with_exit( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___exit__ ) );
            PyObjectTemporary _python_tmp_with_enter( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___enter__ ) ).asObject() ) );
            PyObject *_python_tmp_indicator = Py_True;
            PythonExceptionKeeper _caught_1;

            PyObjectTempKeeper1 _return_value_1;

            try
            {
                try
                {
                    frame_guard.setLineNumber( 131 );
                    throw ReturnValueException( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_create_cursor ) ).asObject() ) );
                }
                catch ( PythonException &_exception )
                {
                    if ( !_exception.hasTraceback() )
                    {
                        _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                    }
                    else
                    {
                        _exception.addTraceback( frame_guard.getFrame0() );
                    }

                    frame_guard.preserveExistingException();

#if PYTHON_VERSION >= 300
                    ExceptionRestorerFrameGuard restorer( &frame_guard );
#endif
                    _exception.toExceptionHandler();

                    if ( _exception.matches( PyExc_BaseException ) )
                    {
                        frame_guard.detachFrame();
                        _python_tmp_indicator = Py_False;
                        if ( (!( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), _exception.getType(), _exception.getValue(), (PyObject *)_exception.getTraceback() ) ).asObject() ) )) )
                        {
                            {
                                PyTracebackObject *tb = _exception.getTraceback();
                                frame_guard.setLineNumber( tb->tb_lineno );
                                _exception.setTraceback( tb->tb_next );
                                tb->tb_next = NULL;

                                throw;
                            }
                        }
                    }
                    else
                    {
                        PyTracebackObject *tb = _exception.getTraceback();
                        frame_guard.setLineNumber( tb->tb_lineno );
                        _exception.setTraceback( tb->tb_next );
                        tb->tb_next = NULL;

                        throw;
                    }
                }
            }
            catch ( PythonException &_exception )
            {
                if ( !_exception.hasTraceback() )
                {
                    _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                }
                else
                {
                    _exception.addTraceback( frame_guard.getFrame0() );
                }

                _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
                frame_guard.preserveExistingException();

                _exception.toExceptionHandler();
#endif
            }
            catch ( ReturnValueException &e )
            {
                _return_value_1.assign( e.getValue() );
            }

            // Final code:
            if ( ( _python_tmp_indicator == Py_True ) )
            {
                DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), Py_None, Py_None, Py_None ) );
            }
            _caught_1.rethrow();
            if ( _return_value_1.isKeeping() )
            {
                return _return_value_1.asObject();
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_cursor() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_cursor() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_cursor() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_cursor() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_cursor() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_cursor() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_cursor() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_cursor() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_cursor() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_cursor() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_cursor() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_cursor() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_cursor() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_cursor() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "_cursor() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_cursor() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_cursor() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_c883c8871ccc377b1d93403ca0ce582d, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 134 );
        if ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject() != Py_None ) )
        {
            {
                frame_guard.setLineNumber( 135 );
                PyObjectTemporary _python_tmp_with_source( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_wrap_database_errors ) ).asObject() ) );
                PyObjectTemporary _python_tmp_with_exit( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___exit__ ) );
                PyObjectTemporary _python_tmp_with_enter( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___enter__ ) ).asObject() ) );
                PyObject *_python_tmp_indicator = Py_True;
                PythonExceptionKeeper _caught_1;

                PyObjectTempKeeper1 _return_value_1;

                try
                {
                    try
                    {
                        frame_guard.setLineNumber( 136 );
                        throw ReturnValueException( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_commit ) ).asObject() ) );
                    }
                    catch ( PythonException &_exception )
                    {
                        if ( !_exception.hasTraceback() )
                        {
                            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                        }
                        else
                        {
                            _exception.addTraceback( frame_guard.getFrame0() );
                        }

                        frame_guard.preserveExistingException();

#if PYTHON_VERSION >= 300
                        ExceptionRestorerFrameGuard restorer( &frame_guard );
#endif
                        _exception.toExceptionHandler();

                        if ( _exception.matches( PyExc_BaseException ) )
                        {
                            frame_guard.detachFrame();
                            _python_tmp_indicator = Py_False;
                            if ( (!( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), _exception.getType(), _exception.getValue(), (PyObject *)_exception.getTraceback() ) ).asObject() ) )) )
                            {
                                {
                                    PyTracebackObject *tb = _exception.getTraceback();
                                    frame_guard.setLineNumber( tb->tb_lineno );
                                    _exception.setTraceback( tb->tb_next );
                                    tb->tb_next = NULL;

                                    throw;
                                }
                            }
                        }
                        else
                        {
                            PyTracebackObject *tb = _exception.getTraceback();
                            frame_guard.setLineNumber( tb->tb_lineno );
                            _exception.setTraceback( tb->tb_next );
                            tb->tb_next = NULL;

                            throw;
                        }
                    }
                }
                catch ( PythonException &_exception )
                {
                    if ( !_exception.hasTraceback() )
                    {
                        _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                    }
                    else
                    {
                        _exception.addTraceback( frame_guard.getFrame0() );
                    }

                    _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
                    frame_guard.preserveExistingException();

                    _exception.toExceptionHandler();
#endif
                }
                catch ( ReturnValueException &e )
                {
                    _return_value_1.assign( e.getValue() );
                }

                // Final code:
                if ( ( _python_tmp_indicator == Py_True ) )
                {
                    DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), Py_None, Py_None, Py_None ) );
                }
                _caught_1.rethrow();
                if ( _return_value_1.isKeeping() )
                {
                    return _return_value_1.asObject();
                }
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_commit() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_commit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_commit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_commit() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_commit() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_commit() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_commit() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_commit() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_commit() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_commit() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_commit() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_commit() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_commit() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_commit() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "_commit() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_commit() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_commit() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_a7061a404e963f5afac433a3c2a9ad4f, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 139 );
        if ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject() != Py_None ) )
        {
            {
                frame_guard.setLineNumber( 140 );
                PyObjectTemporary _python_tmp_with_source( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_wrap_database_errors ) ).asObject() ) );
                PyObjectTemporary _python_tmp_with_exit( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___exit__ ) );
                PyObjectTemporary _python_tmp_with_enter( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___enter__ ) ).asObject() ) );
                PyObject *_python_tmp_indicator = Py_True;
                PythonExceptionKeeper _caught_1;

                PyObjectTempKeeper1 _return_value_1;

                try
                {
                    try
                    {
                        frame_guard.setLineNumber( 141 );
                        throw ReturnValueException( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_rollback ) ).asObject() ) );
                    }
                    catch ( PythonException &_exception )
                    {
                        if ( !_exception.hasTraceback() )
                        {
                            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                        }
                        else
                        {
                            _exception.addTraceback( frame_guard.getFrame0() );
                        }

                        frame_guard.preserveExistingException();

#if PYTHON_VERSION >= 300
                        ExceptionRestorerFrameGuard restorer( &frame_guard );
#endif
                        _exception.toExceptionHandler();

                        if ( _exception.matches( PyExc_BaseException ) )
                        {
                            frame_guard.detachFrame();
                            _python_tmp_indicator = Py_False;
                            if ( (!( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), _exception.getType(), _exception.getValue(), (PyObject *)_exception.getTraceback() ) ).asObject() ) )) )
                            {
                                {
                                    PyTracebackObject *tb = _exception.getTraceback();
                                    frame_guard.setLineNumber( tb->tb_lineno );
                                    _exception.setTraceback( tb->tb_next );
                                    tb->tb_next = NULL;

                                    throw;
                                }
                            }
                        }
                        else
                        {
                            PyTracebackObject *tb = _exception.getTraceback();
                            frame_guard.setLineNumber( tb->tb_lineno );
                            _exception.setTraceback( tb->tb_next );
                            tb->tb_next = NULL;

                            throw;
                        }
                    }
                }
                catch ( PythonException &_exception )
                {
                    if ( !_exception.hasTraceback() )
                    {
                        _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                    }
                    else
                    {
                        _exception.addTraceback( frame_guard.getFrame0() );
                    }

                    _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
                    frame_guard.preserveExistingException();

                    _exception.toExceptionHandler();
#endif
                }
                catch ( ReturnValueException &e )
                {
                    _return_value_1.assign( e.getValue() );
                }

                // Final code:
                if ( ( _python_tmp_indicator == Py_True ) )
                {
                    DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), Py_None, Py_None, Py_None ) );
                }
                _caught_1.rethrow();
                if ( _return_value_1.isKeeping() )
                {
                    return _return_value_1.asObject();
                }
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_rollback() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_rollback() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_rollback() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_rollback() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_rollback() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_rollback() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_rollback() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_rollback() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_rollback() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_rollback() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_rollback() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_rollback() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_rollback() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_rollback() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "_rollback() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_rollback() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_rollback() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_6e09fa3ef8b9ec4470e3fda9f0224fe7, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 144 );
        if ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject() != Py_None ) )
        {
            {
                frame_guard.setLineNumber( 145 );
                PyObjectTemporary _python_tmp_with_source( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_wrap_database_errors ) ).asObject() ) );
                PyObjectTemporary _python_tmp_with_exit( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___exit__ ) );
                PyObjectTemporary _python_tmp_with_enter( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_SPECIAL( _python_tmp_with_source.asObject(), _python_str_plain___enter__ ) ).asObject() ) );
                PyObject *_python_tmp_indicator = Py_True;
                PythonExceptionKeeper _caught_1;

                PyObjectTempKeeper1 _return_value_1;

                try
                {
                    try
                    {
                        frame_guard.setLineNumber( 146 );
                        throw ReturnValueException( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_close ) ).asObject() ) );
                    }
                    catch ( PythonException &_exception )
                    {
                        if ( !_exception.hasTraceback() )
                        {
                            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                        }
                        else
                        {
                            _exception.addTraceback( frame_guard.getFrame0() );
                        }

                        frame_guard.preserveExistingException();

#if PYTHON_VERSION >= 300
                        ExceptionRestorerFrameGuard restorer( &frame_guard );
#endif
                        _exception.toExceptionHandler();

                        if ( _exception.matches( PyExc_BaseException ) )
                        {
                            frame_guard.detachFrame();
                            _python_tmp_indicator = Py_False;
                            if ( (!( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), _exception.getType(), _exception.getValue(), (PyObject *)_exception.getTraceback() ) ).asObject() ) )) )
                            {
                                {
                                    PyTracebackObject *tb = _exception.getTraceback();
                                    frame_guard.setLineNumber( tb->tb_lineno );
                                    _exception.setTraceback( tb->tb_next );
                                    tb->tb_next = NULL;

                                    throw;
                                }
                            }
                        }
                        else
                        {
                            PyTracebackObject *tb = _exception.getTraceback();
                            frame_guard.setLineNumber( tb->tb_lineno );
                            _exception.setTraceback( tb->tb_next );
                            tb->tb_next = NULL;

                            throw;
                        }
                    }
                }
                catch ( PythonException &_exception )
                {
                    if ( !_exception.hasTraceback() )
                    {
                        _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
                    }
                    else
                    {
                        _exception.addTraceback( frame_guard.getFrame0() );
                    }

                    _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
                    frame_guard.preserveExistingException();

                    _exception.toExceptionHandler();
#endif
                }
                catch ( ReturnValueException &e )
                {
                    _return_value_1.assign( e.getValue() );
                }

                // Final code:
                if ( ( _python_tmp_indicator == Py_True ) )
                {
                    DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( _python_tmp_with_exit.asObject(), Py_None, Py_None, Py_None ) );
                }
                _caught_1.rethrow();
                if ( _return_value_1.isKeeping() )
                {
                    return _return_value_1.asObject();
                }
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_close() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_close() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_close() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_close() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_close() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_close() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_close() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_close() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_close() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_close() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_close() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_close() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_close() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_close() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "_close() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_close() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_close() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalVariable _python_var_cursor( _python_str_plain_cursor );

    // Actual function code.
    static PyFrameObject *frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_ea2848d8dd09abe4069bee2edaa61c23, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 154 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_thread_sharing ) ).asObject() ) );
        frame_guard.setLineNumber( 155 );
        if ( ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_use_debug_cursor ) ).asObject() ) || ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_use_debug_cursor ) ).asObject() == Py_None ) && CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_settings.asObject0(), _python_str_plain_DEBUG ) ).asObject() ) ) ) )
        {
            frame_guard.setLineNumber( 157 );
            {
                PyObjectTempKeeper1 call1;
                _python_var_cursor.assign1( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_make_debug_cursor ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__cursor ) ).asObject() ) ).asObject() ) ) );
            }
        }
        else
        {
            frame_guard.setLineNumber( 159 );
            {
                PyObjectTempKeeper1 call3;
                PyObjectTempKeeper1 call4;
                _python_var_cursor.assign1( ( call3.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_util.asObject0(), _python_str_plain_CursorWrapper ) ), call4.assign( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__cursor ) ).asObject() ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), call4.asObject0(), _python_var_self.asObject() ) ) );
            }
        }
        frame_guard.setLineNumber( 160 );
        return _python_var_cursor.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( _python_var_cursor.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "cursor() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "cursor() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "cursor() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "cursor() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "cursor() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "cursor() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "cursor() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "cursor() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "cursor() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "cursor() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "cursor() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "cursor() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "cursor() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "cursor() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "cursor() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "cursor() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "cursor() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_a051cea9086ed3bf893fa50fb77700d9, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 166 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_thread_sharing ) ).asObject() ) );
        frame_guard.setLineNumber( 167 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_no_atomic_block ) ).asObject() ) );
        frame_guard.setLineNumber( 168 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__commit ) ).asObject() ) );
        frame_guard.setLineNumber( 169 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_set_clean ) ).asObject() ) );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "commit() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "commit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "commit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "commit() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "commit() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "commit() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "commit() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "commit() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "commit() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "commit() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "commit() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "commit() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "commit() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "commit() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "commit() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "commit() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "commit() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_4fe5cba5560e946bc359afe5336cc8f5, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 175 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_thread_sharing ) ).asObject() ) );
        frame_guard.setLineNumber( 176 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_no_atomic_block ) ).asObject() ) );
        frame_guard.setLineNumber( 177 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__rollback ) ).asObject() ) );
        frame_guard.setLineNumber( 178 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_set_clean ) ).asObject() ) );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "rollback() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "rollback() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "rollback() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "rollback() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "rollback() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "rollback() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "rollback() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "rollback() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "rollback() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "rollback() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "rollback() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "rollback() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "rollback() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "rollback() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "rollback() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "rollback() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "rollback() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_9366b66efe29463c9b853457607bef10, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 184 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_thread_sharing ) ).asObject() ) );
        frame_guard.setLineNumber( 188 );
        PythonExceptionKeeper _caught_1;


        try
        {
            frame_guard.setLineNumber( 189 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__close ) ).asObject() ) );
        }
        catch ( PythonException &_exception )
        {
            if ( !_exception.hasTraceback() )
            {
                _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
            }
            else
            {
                _exception.addTraceback( frame_guard.getFrame0() );
            }

            _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
            frame_guard.preserveExistingException();

            _exception.toExceptionHandler();
#endif
        }

        // Final code:
        frame_guard.setLineNumber( 191 );
        SET_ATTRIBUTE( Py_None, _python_var_self.asObject(), _python_str_plain_connection );
        _caught_1.rethrow();
        frame_guard.setLineNumber( 192 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_set_clean ) ).asObject() ) );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "close() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "close() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "close() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "close() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "close() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "close() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "close() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "close() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "close() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "close() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "close() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "close() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "close() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "close() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "close() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "close() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "close() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sid )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sid( _python_str_plain_sid, _python_par_sid );

    // Actual function code.
    static PyFrameObject *frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_bb395879407e89ab514c7e21bab2ab0b, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 197 );
        {
            PyObjectTempKeeper1 call1;
            PyObjectTempKeeper1 call3;
            DECREASE_REFCOUNT( ( call3.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_cursor ) ).asObject() ) ).asObject(), _python_str_plain_execute ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_ops ) ).asObject(), _python_str_plain_savepoint_create_sql ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sid.asObject() ) ) ).asObject() ) ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sid.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sid = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_savepoint() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sid == key )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sid, key ) )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_savepoint() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_savepoint() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_savepoint() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_savepoint() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_savepoint() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_savepoint() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_savepoint() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_savepoint() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_savepoint() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sid != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_savepoint() got multiple values for keyword argument 'sid'" );
             goto error_exit;
         }

        _python_par_sid = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_sid );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sid );

    return NULL;
}

static PyObject *dparse_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sid )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sid( _python_str_plain_sid, _python_par_sid );

    // Actual function code.
    static PyFrameObject *frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_2d8099ead333d11a4118447c2b713f27, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 200 );
        {
            PyObjectTempKeeper1 call1;
            PyObjectTempKeeper1 call3;
            DECREASE_REFCOUNT( ( call3.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_cursor ) ).asObject() ) ).asObject(), _python_str_plain_execute ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_ops ) ).asObject(), _python_str_plain_savepoint_rollback_sql ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sid.asObject() ) ) ).asObject() ) ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sid.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sid = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_rollback() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_rollback() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sid == key )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_rollback() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_rollback() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sid, key ) )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_rollback() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_savepoint_rollback() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_rollback() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_savepoint_rollback() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sid != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_savepoint_rollback() got multiple values for keyword argument 'sid'" );
             goto error_exit;
         }

        _python_par_sid = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_sid );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sid );

    return NULL;
}

static PyObject *dparse_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sid )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sid( _python_str_plain_sid, _python_par_sid );

    // Actual function code.
    static PyFrameObject *frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_6a85106c13f3f4ea39cf584ff76b3349, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 203 );
        {
            PyObjectTempKeeper1 call1;
            PyObjectTempKeeper1 call3;
            DECREASE_REFCOUNT( ( call3.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_cursor ) ).asObject() ) ).asObject(), _python_str_plain_execute ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_ops ) ).asObject(), _python_str_plain_savepoint_commit_sql ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sid.asObject() ) ) ).asObject() ) ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sid.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sid = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_commit() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_commit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sid == key )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_commit() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_commit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sid, key ) )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_commit() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_savepoint_commit() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_commit() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_savepoint_commit() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sid != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_savepoint_commit() got multiple values for keyword argument 'sid'" );
             goto error_exit;
         }

        _python_par_sid = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_sid );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sid );

    return NULL;
}

static PyObject *dparse_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_b2d58942ed67bc577fb7ac25f46c02bf, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 207 );
        {
            PyObjectTempKeeper1 keeper_0;
            return INCREASE_REFCOUNT( ( CHECK_IF_TRUE( keeper_0.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_features ) ).asObject(), _python_str_plain_uses_savepoints ) ) ) ? UNARY_OPERATION( UNARY_NOT, PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_autocommit ) ).asObject() ) : PyObjectTemporary( keeper_0.asObject() ).asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_allowed() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_allowed() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_allowed() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_savepoint_allowed() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_savepoint_allowed() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_savepoint_allowed() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalVariable _python_var_thread_ident( _python_str_plain_thread_ident );
    PyObjectLocalVariable _python_var_tid( _python_str_plain_tid );
    PyObjectLocalVariable _python_var_sid( _python_str_plain_sid );

    // Actual function code.
    static PyFrameObject *frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_ca0a51ea0e1138cf11227618d1754d22, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 217 );
        if ( (!( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__savepoint_allowed ) ).asObject() ) ).asObject() ) )) )
        {
            return INCREASE_REFCOUNT( Py_None );
        }
        frame_guard.setLineNumber( 220 );
        _python_var_thread_ident.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_thread.asObject0(), _python_str_plain_get_ident ) ).asObject() ) );
        frame_guard.setLineNumber( 221 );
        _python_var_tid.assign1( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( TO_STR( _python_var_thread_ident.asObject() ) ).asObject(), _python_str_plain_replace ) ).asObject(), _python_str_chr_45, _python_str_empty ) );
        {
            frame_guard.setLineNumber( 223 );
            PyObjectTemporary _python_tmp_inplace_start( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_savepoint_state ) );
            PyObjectTemporary _python_tmp_inplace_end( BINARY_OPERATION( PyNumber_InPlaceAdd, _python_tmp_inplace_start.asObject(), _python_int_pos_1 ) );
            if ( ( _python_tmp_inplace_start.asObject() != _python_tmp_inplace_end.asObject() ) )
            {
                frame_guard.setLineNumber( 223 );
                {
                        PyObject *tmp_identifier = _python_tmp_inplace_end.asObject();
                        SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_savepoint_state );
                }
            }
        }
        frame_guard.setLineNumber( 224 );
        {
            PyObjectTempKeeper0 make_tuple1;
            _python_var_sid.assign1( BINARY_OPERATION_REMAINDER( _python_str_digest_3efbf57751883255a8f5fcb70992792b, PyObjectTemporary( ( make_tuple1.assign( _python_var_tid.asObject() ), MAKE_TUPLE2( make_tuple1.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_savepoint_state ) ).asObject() ) ) ).asObject() ) );
        }
        frame_guard.setLineNumber( 226 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_thread_sharing ) ).asObject() ) );
        frame_guard.setLineNumber( 227 );
        {
            PyObjectTempKeeper1 call3;
            DECREASE_REFCOUNT( ( call3.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__savepoint ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), _python_var_sid.asObject() ) ) );
        }
        frame_guard.setLineNumber( 229 );
        return _python_var_sid.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( _python_var_sid.updateLocalsDict( _python_var_tid.updateLocalsDict( _python_var_thread_ident.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "savepoint() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "savepoint() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "savepoint() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "savepoint() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "savepoint() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "savepoint() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "savepoint() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sid )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sid( _python_str_plain_sid, _python_par_sid );

    // Actual function code.
    static PyFrameObject *frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_e477969a3b99ca32a38e82748774b370, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 235 );
        if ( (!( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__savepoint_allowed ) ).asObject() ) ).asObject() ) )) )
        {
            return INCREASE_REFCOUNT( Py_None );
        }
        frame_guard.setLineNumber( 238 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_thread_sharing ) ).asObject() ) );
        frame_guard.setLineNumber( 239 );
        {
            PyObjectTempKeeper1 call1;
            DECREASE_REFCOUNT( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__savepoint_rollback ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sid.asObject() ) ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sid.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sid = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sid == key )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sid, key ) )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "savepoint_rollback() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_rollback() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sid != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_rollback() got multiple values for keyword argument 'sid'" );
             goto error_exit;
         }

        _python_par_sid = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_sid );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sid );

    return NULL;
}

static PyObject *dparse_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sid )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sid( _python_str_plain_sid, _python_par_sid );

    // Actual function code.
    static PyFrameObject *frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_255a66cf84f179184570e486049da0c6, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 245 );
        if ( (!( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__savepoint_allowed ) ).asObject() ) ).asObject() ) )) )
        {
            return INCREASE_REFCOUNT( Py_None );
        }
        frame_guard.setLineNumber( 248 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_thread_sharing ) ).asObject() ) );
        frame_guard.setLineNumber( 249 );
        {
            PyObjectTempKeeper1 call1;
            DECREASE_REFCOUNT( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__savepoint_commit ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sid.asObject() ) ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sid.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sid = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sid == key )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sid, key ) )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "savepoint_commit() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_commit() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "savepoint_commit() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "savepoint_commit() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_commit() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "savepoint_commit() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_commit() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sid != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_commit() got multiple values for keyword argument 'sid'" );
             goto error_exit;
         }

        _python_par_sid = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_sid );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sid );

    return NULL;
}

static PyObject *dparse_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_71b6366f77ee9899c9ef82b59e499594, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 255 );
        SET_ATTRIBUTE( _python_int_0, _python_var_self.asObject(), _python_str_plain_savepoint_state );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "clean_savepoints() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "clean_savepoints() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "clean_savepoints() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "clean_savepoints() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "clean_savepoints() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "clean_savepoints() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "clean_savepoints() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "clean_savepoints() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "clean_savepoints() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "clean_savepoints() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "clean_savepoints() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "clean_savepoints() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "clean_savepoints() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "clean_savepoints() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "clean_savepoints() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "clean_savepoints() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "clean_savepoints() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_autocommit )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_autocommit( _python_str_plain_autocommit, _python_par_autocommit );

    // Actual function code.
    static PyFrameObject *frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_ce8dc9cc96f21d45ef26c6feac40a1cf, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 263 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_autocommit.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_autocommit = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_set_autocommit() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_set_autocommit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_autocommit == key )
            {
                if (unlikely( _python_par_autocommit ))
                {
                    PyErr_Format( PyExc_TypeError, "_set_autocommit() got multiple values for keyword argument 'autocommit'" );
                    goto error_exit;
                }

                _python_par_autocommit = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_set_autocommit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_autocommit, key ) )
            {
                if (unlikely( _python_par_autocommit ))
                {
                    PyErr_Format( PyExc_TypeError, "_set_autocommit() got multiple values for keyword argument 'autocommit'" );
                    goto error_exit;
                }

                _python_par_autocommit = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_set_autocommit() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_set_autocommit() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_set_autocommit() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_set_autocommit() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_set_autocommit() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "_set_autocommit() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_set_autocommit() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "_set_autocommit() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_set_autocommit() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_set_autocommit() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_set_autocommit() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "_set_autocommit() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_set_autocommit() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_set_autocommit() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_autocommit != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_set_autocommit() got multiple values for keyword argument 'autocommit'" );
             goto error_exit;
         }

        _python_par_autocommit = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_autocommit );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_autocommit );

    return NULL;
}

static PyObject *dparse_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_managed, PyObject *_python_par_forced )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_managed( _python_str_plain_managed, _python_par_managed );
    PyObjectLocalParameterVariableNoDel _python_var_forced( _python_str_plain_forced, _python_par_forced );

    // Actual function code.
    static PyFrameObject *frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_30b6ca1ebd0b184998958ab5824147a2, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 280 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_no_atomic_block ) ).asObject() ) );
        frame_guard.setLineNumber( 282 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_ensure_connection ) ).asObject() ) );
        frame_guard.setLineNumber( 284 );
        {
            PyObjectTempKeeper1 call1;
            DECREASE_REFCOUNT( ( call1.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_transaction_state ) ).asObject(), _python_str_plain_append ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_managed.asObject() ) ) );
        }
        frame_guard.setLineNumber( 286 );
        if ( ( (!( CHECK_IF_TRUE( _python_var_managed.asObject() ) )) && ( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_is_dirty ) ).asObject() ) ).asObject() ) && (!( CHECK_IF_TRUE( _python_var_forced.asObject() ) )) ) ) )
        {
            frame_guard.setLineNumber( 287 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_commit ) ).asObject() ) );
            frame_guard.setLineNumber( 288 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_set_clean ) ).asObject() ) );
        }
        frame_guard.setLineNumber( 290 );
        {
            PyObjectTempKeeper0 cmp5;
            if ( ( cmp5.assign( _python_var_managed.asObject() ), RICH_COMPARE_BOOL_EQ( cmp5.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_autocommit ) ).asObject() ) ) )
        {
            frame_guard.setLineNumber( 291 );
            {
                PyObjectTempKeeper1 call3;
                DECREASE_REFCOUNT( ( call3.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_set_autocommit ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), UNARY_OPERATION( UNARY_NOT, _python_var_managed.asObject() ) ) ) );
            }
        }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_forced.updateLocalsDict( _python_var_managed.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_managed = NULL;
    PyObject *_python_par_forced = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "enter_transaction_management() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_managed == key )
            {
                if (unlikely( _python_par_managed ))
                {
                    PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'managed'" );
                    goto error_exit;
                }

                _python_par_managed = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_forced == key )
            {
                if (unlikely( _python_par_forced ))
                {
                    PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'forced'" );
                    goto error_exit;
                }

                _python_par_forced = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_managed, key ) )
            {
                if (unlikely( _python_par_managed ))
                {
                    PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'managed'" );
                    goto error_exit;
                }

                _python_par_managed = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_forced, key ) )
            {
                if (unlikely( _python_par_forced ))
                {
                    PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'forced'" );
                    goto error_exit;
                }

                _python_par_forced = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "enter_transaction_management() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "enter_transaction_management() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_managed != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'managed'" );
             goto error_exit;
         }

        _python_par_managed = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_forced != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "enter_transaction_management() got multiple values for keyword argument 'forced'" );
             goto error_exit;
         }

        _python_par_forced = INCREASE_REFCOUNT( args[ 2 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_managed == NULL )
    {
        _python_par_managed = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_managed );
    }
    if ( _python_par_forced == NULL )
    {
        _python_par_forced = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 1 ) );
        assertObject( _python_par_forced );
    }


    return impl_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_managed, _python_par_forced );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_managed );
    Py_XDECREF( _python_par_forced );

    return NULL;
}

static PyObject *dparse_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalVariable _python_var_managed( _python_str_plain_managed );

    // Actual function code.
    static PyFrameObject *frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_a3317b0bb44eabe1aa0c11eb1a8ac30d, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 299 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_no_atomic_block ) ).asObject() ) );
        frame_guard.setLineNumber( 301 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_ensure_connection ) ).asObject() ) );
        frame_guard.setLineNumber( 303 );
        if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_transaction_state ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 304 );
            DEL_SUBSCRIPT( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_transaction_state ) ).asObject(), _python_int_neg_1 );
        }
        else
        {
            frame_guard.setLineNumber( 306 );
            {
                    PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_ARGS( _mvar_django__db__backends_TransactionManagementError.asObject0(), _python_str_digest_3de5e73740a5561d2d3013b8c351dc4e ) );
                    RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
            }
        }
        frame_guard.setLineNumber( 309 );
        if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_transaction_state ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 310 );
            _python_var_managed.assign1( LOOKUP_SUBSCRIPT_CONST( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_transaction_state ) ).asObject(), _python_int_neg_1, -1 ) );
        }
        else
        {
            frame_guard.setLineNumber( 312 );
            _python_var_managed.assign0( UNARY_OPERATION( UNARY_NOT, PyObjectTemporary( LOOKUP_SUBSCRIPT( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_settings_dict ) ).asObject(), _python_str_plain_AUTOCOMMIT ) ).asObject() ) );
        }
        frame_guard.setLineNumber( 314 );
        if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__dirty ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 315 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_rollback ) ).asObject() ) );
            frame_guard.setLineNumber( 316 );
            {
                PyObjectTempKeeper0 cmp3;
                if ( ( cmp3.assign( _python_var_managed.asObject() ), RICH_COMPARE_BOOL_EQ( cmp3.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_autocommit ) ).asObject() ) ) )
            {
                frame_guard.setLineNumber( 317 );
                {
                    PyObjectTempKeeper1 call1;
                    DECREASE_REFCOUNT( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_set_autocommit ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), UNARY_OPERATION( UNARY_NOT, _python_var_managed.asObject() ) ) ) );
                }
            }
            }
            frame_guard.setLineNumber( 318 );
            {
                    PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_ARGS( _mvar_django__db__backends_TransactionManagementError.asObject0(), _python_str_digest_8a52752a8b521f99f664a220c05cee63 ) );
                    RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
            }
        }
        frame_guard.setLineNumber( 321 );
        {
            PyObjectTempKeeper0 cmp7;
            if ( ( cmp7.assign( _python_var_managed.asObject() ), RICH_COMPARE_BOOL_EQ( cmp7.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_autocommit ) ).asObject() ) ) )
        {
            frame_guard.setLineNumber( 322 );
            {
                PyObjectTempKeeper1 call5;
                DECREASE_REFCOUNT( ( call5.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_set_autocommit ) ), CALL_FUNCTION_WITH_ARGS( call5.asObject0(), UNARY_OPERATION( UNARY_NOT, _python_var_managed.asObject() ) ) ) );
            }
        }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( _python_var_managed.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "leave_transaction_management() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "leave_transaction_management() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "leave_transaction_management() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "leave_transaction_management() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "leave_transaction_management() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "leave_transaction_management() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_autocommit )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_autocommit( _python_str_plain_autocommit, _python_par_autocommit );

    // Actual function code.
    static PyFrameObject *frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_538c066319d49732e3bd6578639e9ea2, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 328 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_validate_no_atomic_block ) ).asObject() ) );
        frame_guard.setLineNumber( 329 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_ensure_connection ) ).asObject() ) );
        frame_guard.setLineNumber( 330 );
        {
            PyObjectTempKeeper1 call1;
            DECREASE_REFCOUNT( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__set_autocommit ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_autocommit.asObject() ) ) );
        }
        frame_guard.setLineNumber( 331 );
        {
                PyObject *tmp_identifier = _python_var_autocommit.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_autocommit );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_autocommit.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_autocommit = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "set_autocommit() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "set_autocommit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_autocommit == key )
            {
                if (unlikely( _python_par_autocommit ))
                {
                    PyErr_Format( PyExc_TypeError, "set_autocommit() got multiple values for keyword argument 'autocommit'" );
                    goto error_exit;
                }

                _python_par_autocommit = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "set_autocommit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_autocommit, key ) )
            {
                if (unlikely( _python_par_autocommit ))
                {
                    PyErr_Format( PyExc_TypeError, "set_autocommit() got multiple values for keyword argument 'autocommit'" );
                    goto error_exit;
                }

                _python_par_autocommit = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "set_autocommit() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "set_autocommit() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "set_autocommit() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "set_autocommit() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "set_autocommit() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "set_autocommit() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "set_autocommit() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "set_autocommit() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "set_autocommit() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "set_autocommit() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "set_autocommit() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "set_autocommit() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "set_autocommit() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "set_autocommit() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_autocommit != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "set_autocommit() got multiple values for keyword argument 'autocommit'" );
             goto error_exit;
         }

        _python_par_autocommit = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_autocommit );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_autocommit );

    return NULL;
}

static PyObject *dparse_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_6e34eed68125dff5ca29c65a79ea7acf, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 337 );
        if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_in_atomic_block ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 338 );
            {
                    PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_ARGS( _mvar_django__db__backends_TransactionManagementError.asObject0(), _python_str_digest_1685f90939d557480306a55571c1f50d ) );
                    RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "validate_no_atomic_block() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "validate_no_atomic_block() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_43c761f38f1eecffeefcaaee1d88e1c8, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 346 );
        if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__dirty ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 347 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_rollback ) ).asObject() ) );
        }
        frame_guard.setLineNumber( 348 );
        while( true )
        {
            frame_guard.setLineNumber( 348 );
            if ( (!( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_transaction_state ) ).asObject() ) )) )
            {
                frame_guard.setLineNumber( 348 );
                break;
            }
            frame_guard.setLineNumber( 349 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_leave_transaction_management ) ).asObject() ) );

           CONSIDER_THREADING();
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "abort() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "abort() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "abort() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "abort() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "abort() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "abort() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "abort() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "abort() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "abort() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "abort() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "abort() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "abort() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "abort() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "abort() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "abort() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "abort() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "abort() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_299f7d78cbab83e4a95c219e54ca3e93, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 356 );
        return LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__dirty );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "is_dirty() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "is_dirty() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "is_dirty() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "is_dirty() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "is_dirty() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "is_dirty() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "is_dirty() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "is_dirty() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "is_dirty() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "is_dirty() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "is_dirty() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "is_dirty() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "is_dirty() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "is_dirty() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "is_dirty() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "is_dirty() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "is_dirty() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_c0340cc4d08afb26d20c3c6e29eeac13, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 364 );
        if ( (!( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_autocommit ) ).asObject() ) )) )
        {
            frame_guard.setLineNumber( 365 );
            SET_ATTRIBUTE( Py_True, _python_var_self.asObject(), _python_str_plain__dirty );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "set_dirty() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "set_dirty() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "set_dirty() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "set_dirty() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "set_dirty() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "set_dirty() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "set_dirty() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "set_dirty() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "set_dirty() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "set_dirty() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "set_dirty() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "set_dirty() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "set_dirty() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "set_dirty() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "set_dirty() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "set_dirty() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "set_dirty() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_7925c1cd796c69b346159488432bcabf, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 373 );
        SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain__dirty );
        frame_guard.setLineNumber( 374 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_clean_savepoints ) ).asObject() ) );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "set_clean() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "set_clean() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "set_clean() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "set_clean() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "set_clean() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "set_clean() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "set_clean() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "set_clean() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "set_clean() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "set_clean() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "set_clean() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "set_clean() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "set_clean() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "set_clean() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "set_clean() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "set_clean() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "set_clean() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}




struct _context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t
{
    // The generator function instance can access its parameters from creation time.
    PyObjectLocalParameterVariableNoDel python_var_self;
    PyObjectLocalVariable python_var_disabled;
};

static void _context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_destructor( void *context_voidptr )
{
    _context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *_python_context = (struct _context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *)context_voidptr;

    delete _python_context;
}

static void function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_context( Nuitka_GeneratorObject *generator )
{
    {
        // Make context accessible if one is used.

        NUITKA_MAY_BE_UNUSED struct _context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *_python_context = (_context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *)generator->m_context;


        // Local variable inits
        _python_context->python_var_disabled.setVariableName( _python_str_plain_disabled );

        // Actual function code.
        static PyFrameObject *frame_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

        // Must be inside block, or else its d-tor will not be run.
        if ( isFrameUnusable( frame_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
        {
            if ( frame_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
            {
#if _DEBUG_REFRAME
                puts( "reframe for function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
                Py_DECREF( frame_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
            }

            frame_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_0d86529430a7b6aa511fc15f24a0a047, _module_django__db__backends );
        }

        Py_INCREF( frame_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        generator->m_frame = frame_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends;

        Py_CLEAR( generator->m_frame->f_back );

        generator->m_frame->f_back = PyThreadState_GET()->frame;
        Py_INCREF( generator->m_frame->f_back );

        PyThreadState_GET()->frame = generator->m_frame;

        FrameGuardLight frame_guard( &generator->m_frame );

        // TODO: The inject of the exception through C++ is very non-optimal, this flag
        // now indicates only if the exception occurs initially as supposed, or during
        // life, this could and should be shortcut.
        bool traceback;

        try
        {
            // TODO: In case we don't raise exceptions ourselves, we would still have to do this, so
            // beware to not optimize this away for generators without a replacement.
            traceback = true;
            CHECK_EXCEPTION( generator );
            traceback = false;

            frame_guard.setLineNumber( 383 );
            _python_context->python_var_disabled.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_context->python_var_self.asObject(), _python_str_plain_disable_constraint_checking ) ).asObject() ) );
            frame_guard.setLineNumber( 384 );
            PythonExceptionKeeper _caught_1;


            try
            {
                frame_guard.setLineNumber( 385 );
                YIELD_VALUE( generator, INCREASE_REFCOUNT( Py_None ) );
            }
            catch ( PythonException &_exception )
            {
                if ( !_exception.hasTraceback() )
                {
                    _exception.setTraceback( MAKE_TRACEBACK( INCREASE_REFCOUNT( generator->m_frame ) ) );
                }
                else
                {
                    _exception.addTraceback( frame_guard.getFrame0() );
                }

                _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
                frame_guard.preserveExistingException();

                _exception.toExceptionHandler();
#endif
            }

            // Final code:
            frame_guard.setLineNumber( 387 );
            if ( CHECK_IF_TRUE( _python_context->python_var_disabled.asObject() ) )
            {
                frame_guard.setLineNumber( 388 );
                DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_context->python_var_self.asObject(), _python_str_plain_enable_constraint_checking ) ).asObject() ) );
            }
            _caught_1.rethrow();

            PyErr_SetNone( PyExc_StopIteration );
        }
        catch ( PythonException &_exception )
        {
            if ( !_exception.hasTraceback() )
            {
                _exception.setTraceback( MAKE_TRACEBACK( INCREASE_REFCOUNT( generator->m_frame ) ) );
            }
            else if ( traceback == false )
            {
                _exception.addTraceback( generator->m_frame );
            }
            _exception.toPython();

            // TODO: Moving this code is not allowed yet.
            generator->m_yielded = NULL;
        }
    }

    // TODO: Won't return, we should tell the compiler about that.
    generator->m_yielded = NULL;
    swapFiber( &generator->m_yielder_context, &generator->m_caller_context );
}

static PyObject *impl_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // Create context if any
    struct _context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *_python_context = new _context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t;

    try
    {
        PyObject *result = Nuitka_Generator_New(
            function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_context,
            _python_str_plain_constraint_checks_disabled,
            _codeobj_0d86529430a7b6aa511fc15f24a0a047,
            _python_context,
            _context_generator_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_destructor
        );

        if (unlikely( result == NULL ))
        {
            PyErr_Format( PyExc_RuntimeError, "cannot create function constraint_checks_disabled" );
            return NULL;
        }

        // Copy to context parameter values and closured variables if any.
        _python_context->python_var_self.setVariableNameAndValue( _python_str_plain_self, _python_par_self );

        return result;
    }
    catch ( PythonException &_exception )
    {
        _exception.toPython();

        return NULL;
    }
}
static PyObject *fparse_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "constraint_checks_disabled() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "constraint_checks_disabled() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_False );
}
static PyObject *fparse_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "disable_constraint_checking() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "disable_constraint_checking() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "disable_constraint_checking() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "disable_constraint_checking() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "disable_constraint_checking() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "disable_constraint_checking() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "enable_constraint_checking() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "enable_constraint_checking() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "enable_constraint_checking() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "enable_constraint_checking() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "enable_constraint_checking() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "enable_constraint_checking() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_table_names )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_table_names( _python_str_plain_table_names, _python_par_table_names );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_table_names = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "check_constraints() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "check_constraints() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_table_names == key )
            {
                if (unlikely( _python_par_table_names ))
                {
                    PyErr_Format( PyExc_TypeError, "check_constraints() got multiple values for keyword argument 'table_names'" );
                    goto error_exit;
                }

                _python_par_table_names = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "check_constraints() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_table_names, key ) )
            {
                if (unlikely( _python_par_table_names ))
                {
                    PyErr_Format( PyExc_TypeError, "check_constraints() got multiple values for keyword argument 'table_names'" );
                    goto error_exit;
                }

                _python_par_table_names = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "check_constraints() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "check_constraints() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "check_constraints() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "check_constraints() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "check_constraints() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "check_constraints() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "check_constraints() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "check_constraints() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "check_constraints() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "check_constraints() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "check_constraints() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "check_constraints() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "check_constraints() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "check_constraints() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_table_names != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "check_constraints() got multiple values for keyword argument 'table_names'" );
             goto error_exit;
         }

        _python_par_table_names = INCREASE_REFCOUNT( args[ 1 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_table_names == NULL )
    {
        _python_par_table_names = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_table_names );
    }


    return impl_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_table_names );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_table_names );

    return NULL;
}

static PyObject *dparse_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_f68eddb5d24db2f1d885c40adbb06ce5, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 420 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "is_usable() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "is_usable() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "is_usable() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "is_usable() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "is_usable() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "is_usable() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "is_usable() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "is_usable() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "is_usable() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "is_usable() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "is_usable() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "is_usable() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "is_usable() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "is_usable() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "is_usable() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "is_usable() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "is_usable() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_e620b824cf080d4c4459517cfff1a786, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 427 );
        if ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject() != Py_None ) )
        {
            frame_guard.setLineNumber( 430 );
            {
                PyObjectTempKeeper1 cmp1;
                if ( ( cmp1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_autocommit ) ), RICH_COMPARE_BOOL_NE( cmp1.asObject0(), PyObjectTemporary( LOOKUP_SUBSCRIPT( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_settings_dict ) ).asObject(), _python_str_plain_AUTOCOMMIT ) ).asObject() ) ) )
            {
                frame_guard.setLineNumber( 431 );
                DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_close ) ).asObject() ) );
                return INCREASE_REFCOUNT( Py_None );
            }
            }
            frame_guard.setLineNumber( 434 );
            if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_errors_occurred ) ).asObject() ) )
            {
                frame_guard.setLineNumber( 435 );
                if ( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_is_usable ) ).asObject() ) ).asObject() ) )
                {
                    frame_guard.setLineNumber( 436 );
                    SET_ATTRIBUTE( Py_False, _python_var_self.asObject(), _python_str_plain_errors_occurred );
                }
                else
                {
                    frame_guard.setLineNumber( 438 );
                    DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_close ) ).asObject() ) );
                    return INCREASE_REFCOUNT( Py_None );
                }
            }
            frame_guard.setLineNumber( 441 );
            {
                PyObjectTempKeeper1 cmp3;
                if ( ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_close_at ) ).asObject() != Py_None ) && ( cmp3.assign( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_time.asObject0(), _python_str_plain_time ) ).asObject() ) ), RICH_COMPARE_BOOL_GE( cmp3.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_close_at ) ).asObject() ) ) ) )
            {
                frame_guard.setLineNumber( 442 );
                DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_close ) ).asObject() ) );
                return INCREASE_REFCOUNT( Py_None );
            }
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "close_if_unusable_or_obsolete() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "close_if_unusable_or_obsolete() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_623f58120be42ce03c560a1bd9fa081b, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 454 );
        {
            PyObjectTempKeeper1 cmp6;
            if ( (!( ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_allow_thread_sharing ) ).asObject() ) || ( cmp6.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__thread_ident ) ), RICH_COMPARE_BOOL_EQ( cmp6.asObject0(), PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_thread.asObject0(), _python_str_plain_get_ident ) ).asObject() ) ).asObject() ) ) ) )) )
        {
            frame_guard.setLineNumber( 456 );
            {
                PyObjectTempKeeper0 call4;
                PyObjectTempKeeper1 make_tuple1;
                PyObjectTempKeeper1 make_tuple2;
                {
                    PyObjectTemporary tmp_exception_type( ( call4.assign( _mvar_django__db__backends_DatabaseError.asObject0() ), CALL_FUNCTION_WITH_ARGS( call4.asObject0(), PyObjectTemporary( BINARY_OPERATION_REMAINDER( _python_str_digest_04f533f773a41aa87ada46b9bbe5b67d, PyObjectTemporary( ( make_tuple1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_alias ) ), make_tuple2.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__thread_ident ) ), MAKE_TUPLE3( make_tuple1.asObject0(), make_tuple2.asObject0(), PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_thread.asObject0(), _python_str_plain_get_ident ) ).asObject() ) ).asObject() ) ) ).asObject() ) ).asObject() ) ) );
                    RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
            }
            }
        }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "validate_thread_sharing() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_thread_sharing() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_thread_sharing() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "validate_thread_sharing() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "validate_thread_sharing() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "validate_thread_sharing() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_8aabc962a7bb04b21437bcd1e0359c4a, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 469 );
        {
            PyObjectTempKeeper0 call1;
            return ( call1.assign( _mvar_django__db__backends_DatabaseErrorWrapper.asObject0() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_self.asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "wrap_database_errors() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "wrap_database_errors() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "wrap_database_errors() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "wrap_database_errors() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "wrap_database_errors() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "wrap_database_errors() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );

    // Actual function code.
    static PyFrameObject *frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_a63252ab3f76515025c705fb22cc76ca, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 475 );
        {
            PyObjectTempKeeper1 call1;
            PyObjectTempKeeper0 call2;
            return ( call1.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_util.asObject0(), _python_str_plain_CursorDebugWrapper ) ), call2.assign( _python_var_cursor.asObject() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), call2.asObject0(), _python_var_self.asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "make_debug_cursor() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "make_debug_cursor() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "make_debug_cursor() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "make_debug_cursor() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "make_debug_cursor() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "make_debug_cursor() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "make_debug_cursor() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "make_debug_cursor() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "make_debug_cursor() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self, _python_par_cursor );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );

    return NULL;
}

static PyObject *dparse_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}




struct _context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t
{
    // The generator function instance can access its parameters from creation time.
    PyObjectLocalParameterVariableNoDel python_var_self;
    PyObjectLocalVariable python_var_must_close;
    PyObjectLocalVariable python_var_cursor;
};

static void _context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_destructor( void *context_voidptr )
{
    _context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *_python_context = (struct _context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *)context_voidptr;

    delete _python_context;
}

static void function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_context( Nuitka_GeneratorObject *generator )
{
    {
        // Make context accessible if one is used.

        NUITKA_MAY_BE_UNUSED struct _context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *_python_context = (_context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *)generator->m_context;


        // Local variable inits
        _python_context->python_var_must_close.setVariableName( _python_str_plain_must_close );
        _python_context->python_var_cursor.setVariableName( _python_str_plain_cursor );

        // Actual function code.
        static PyFrameObject *frame_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

        // Must be inside block, or else its d-tor will not be run.
        if ( isFrameUnusable( frame_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
        {
            if ( frame_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
            {
#if _DEBUG_REFRAME
                puts( "reframe for function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
                Py_DECREF( frame_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
            }

            frame_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_6212400ff9fddc80a694d7367ced1009, _module_django__db__backends );
        }

        Py_INCREF( frame_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        generator->m_frame = frame_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends;

        Py_CLEAR( generator->m_frame->f_back );

        generator->m_frame->f_back = PyThreadState_GET()->frame;
        Py_INCREF( generator->m_frame->f_back );

        PyThreadState_GET()->frame = generator->m_frame;

        FrameGuardLight frame_guard( &generator->m_frame );

        // TODO: The inject of the exception through C++ is very non-optimal, this flag
        // now indicates only if the exception occurs initially as supposed, or during
        // life, this could and should be shortcut.
        bool traceback;

        try
        {
            // TODO: In case we don't raise exceptions ourselves, we would still have to do this, so
            // beware to not optimize this away for generators without a replacement.
            traceback = true;
            CHECK_EXCEPTION( generator );
            traceback = false;

            frame_guard.setLineNumber( 486 );
            _python_context->python_var_must_close.assign0( BOOL_FROM( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_context->python_var_self.asObject(), _python_str_plain_connection ) ).asObject() == Py_None ) ) );
            frame_guard.setLineNumber( 487 );
            _python_context->python_var_cursor.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_context->python_var_self.asObject(), _python_str_plain_cursor ) ).asObject() ) );
            frame_guard.setLineNumber( 488 );
            PythonExceptionKeeper _caught_1;


            try
            {
                frame_guard.setLineNumber( 489 );
                YIELD_VALUE( generator, _python_context->python_var_cursor.asObject1() );
            }
            catch ( PythonException &_exception )
            {
                if ( !_exception.hasTraceback() )
                {
                    _exception.setTraceback( MAKE_TRACEBACK( INCREASE_REFCOUNT( generator->m_frame ) ) );
                }
                else
                {
                    _exception.addTraceback( frame_guard.getFrame0() );
                }

                _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
                frame_guard.preserveExistingException();

                _exception.toExceptionHandler();
#endif
            }

            // Final code:
            frame_guard.setLineNumber( 491 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_context->python_var_cursor.asObject(), _python_str_plain_close ) ).asObject() ) );
            frame_guard.setLineNumber( 492 );
            if ( CHECK_IF_TRUE( _python_context->python_var_must_close.asObject() ) )
            {
                frame_guard.setLineNumber( 493 );
                DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_context->python_var_self.asObject(), _python_str_plain_close ) ).asObject() ) );
            }
            _caught_1.rethrow();

            PyErr_SetNone( PyExc_StopIteration );
        }
        catch ( PythonException &_exception )
        {
            if ( !_exception.hasTraceback() )
            {
                _exception.setTraceback( MAKE_TRACEBACK( INCREASE_REFCOUNT( generator->m_frame ) ) );
            }
            else if ( traceback == false )
            {
                _exception.addTraceback( generator->m_frame );
            }
            _exception.toPython();

            // TODO: Moving this code is not allowed yet.
            generator->m_yielded = NULL;
        }
    }

    // TODO: Won't return, we should tell the compiler about that.
    generator->m_yielded = NULL;
    swapFiber( &generator->m_yielder_context, &generator->m_caller_context );
}

static PyObject *impl_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // Create context if any
    struct _context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t *_python_context = new _context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_t;

    try
    {
        PyObject *result = Nuitka_Generator_New(
            function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_context,
            _python_str_plain_temporary_connection,
            _codeobj_6212400ff9fddc80a694d7367ced1009,
            _python_context,
            _context_generator_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends_destructor
        );

        if (unlikely( result == NULL ))
        {
            PyErr_Format( PyExc_RuntimeError, "cannot create function temporary_connection" );
            return NULL;
        }

        // Copy to context parameter values and closured variables if any.
        _python_context->python_var_self.setVariableNameAndValue( _python_str_plain_self, _python_par_self );

        return result;
    }
    catch ( PythonException &_exception )
    {
        _exception.toPython();

        return NULL;
    }
}
static PyObject *fparse_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "temporary_connection() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "temporary_connection() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "temporary_connection() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "temporary_connection() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "temporary_connection() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "temporary_connection() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "temporary_connection() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "temporary_connection() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "temporary_connection() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "temporary_connection() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "temporary_connection() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "temporary_connection() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "temporary_connection() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "temporary_connection() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "temporary_connection() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "temporary_connection() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "temporary_connection() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) )
    {
        if ( frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
        }

        frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = MAKE_FRAME( _codeobj_439485a6ce95b942ceb8216ad2478504, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 499 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends );
           frame_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "_start_transaction_under_autocommit() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "_start_transaction_under_autocommit() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



NUITKA_LOCAL_MODULE PyObject *impl_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalVariable _python_var___module__( _python_str_plain___module__ );
    PyObjectLocalVariable _python_var_allows_group_by_pk( _python_str_plain_allows_group_by_pk );
    PyObjectLocalVariable _python_var_needs_datetime_string_cast( _python_str_plain_needs_datetime_string_cast );
    PyObjectLocalVariable _python_var_empty_fetchmany_value( _python_str_plain_empty_fetchmany_value );
    PyObjectLocalVariable _python_var_update_can_self_select( _python_str_plain_update_can_self_select );
    PyObjectLocalVariable _python_var_interprets_empty_strings_as_nulls( _python_str_plain_interprets_empty_strings_as_nulls );
    PyObjectLocalVariable _python_var_ignores_nulls_in_unique_constraints( _python_str_plain_ignores_nulls_in_unique_constraints );
    PyObjectLocalVariable _python_var_can_use_chunked_reads( _python_str_plain_can_use_chunked_reads );
    PyObjectLocalVariable _python_var_can_return_id_from_insert( _python_str_plain_can_return_id_from_insert );
    PyObjectLocalVariable _python_var_has_bulk_insert( _python_str_plain_has_bulk_insert );
    PyObjectLocalVariable _python_var_uses_savepoints( _python_str_plain_uses_savepoints );
    PyObjectLocalVariable _python_var_can_combine_inserts_with_and_without_auto_increment_pk( _python_str_digest_73f421d02c143f5b1ea1e641a36c5f9f );
    PyObjectLocalVariable _python_var_related_fields_match_type( _python_str_plain_related_fields_match_type );
    PyObjectLocalVariable _python_var_allow_sliced_subqueries( _python_str_plain_allow_sliced_subqueries );
    PyObjectLocalVariable _python_var_has_select_for_update( _python_str_plain_has_select_for_update );
    PyObjectLocalVariable _python_var_has_select_for_update_nowait( _python_str_plain_has_select_for_update_nowait );
    PyObjectLocalVariable _python_var_supports_select_related( _python_str_plain_supports_select_related );
    PyObjectLocalVariable _python_var_test_db_allows_multiple_connections( _python_str_plain_test_db_allows_multiple_connections );
    PyObjectLocalVariable _python_var_supports_unspecified_pk( _python_str_plain_supports_unspecified_pk );
    PyObjectLocalVariable _python_var_supports_forward_references( _python_str_plain_supports_forward_references );
    PyObjectLocalVariable _python_var_requires_rollback_on_dirty_transaction( _python_str_plain_requires_rollback_on_dirty_transaction );
    PyObjectLocalVariable _python_var_supports_long_model_names( _python_str_plain_supports_long_model_names );
    PyObjectLocalVariable _python_var_has_real_datatype( _python_str_plain_has_real_datatype );
    PyObjectLocalVariable _python_var_supports_subqueries_in_group_by( _python_str_plain_supports_subqueries_in_group_by );
    PyObjectLocalVariable _python_var_supports_bitwise_or( _python_str_plain_supports_bitwise_or );
    PyObjectLocalVariable _python_var_supports_microsecond_precision( _python_str_plain_supports_microsecond_precision );
    PyObjectLocalVariable _python_var_supports_regex_backreferencing( _python_str_plain_supports_regex_backreferencing );
    PyObjectLocalVariable _python_var_supports_date_lookup_using_string( _python_str_plain_supports_date_lookup_using_string );
    PyObjectLocalVariable _python_var_supports_timezones( _python_str_plain_supports_timezones );
    PyObjectLocalVariable _python_var_has_zoneinfo_database( _python_str_plain_has_zoneinfo_database );
    PyObjectLocalVariable _python_var_requires_explicit_null_ordering_when_grouping( _python_str_digest_6eeefbd09d7a0a356555f30628e0dba3 );
    PyObjectLocalVariable _python_var_supports_1000_query_parameters( _python_str_plain_supports_1000_query_parameters );
    PyObjectLocalVariable _python_var_allows_primary_key_0( _python_str_plain_allows_primary_key_0 );
    PyObjectLocalVariable _python_var_can_defer_constraint_checks( _python_str_plain_can_defer_constraint_checks );
    PyObjectLocalVariable _python_var_supports_mixed_date_datetime_comparisons( _python_str_plain_supports_mixed_date_datetime_comparisons );
    PyObjectLocalVariable _python_var_supports_tablespaces( _python_str_plain_supports_tablespaces );
    PyObjectLocalVariable _python_var_supports_sequence_reset( _python_str_plain_supports_sequence_reset );
    PyObjectLocalVariable _python_var_can_introspect_foreign_keys( _python_str_plain_can_introspect_foreign_keys );
    PyObjectLocalVariable _python_var_can_distinct_on_fields( _python_str_plain_can_distinct_on_fields );
    PyObjectLocalVariable _python_var_autocommits_when_autocommit_is_off( _python_str_plain_autocommits_when_autocommit_is_off );
    PyObjectLocalVariable _python_var___init__( _python_str_plain___init__ );
    PyObjectLocalVariable _python_var_supports_transactions( _python_str_plain_supports_transactions );
    PyObjectLocalVariable _python_var_supports_stddev( _python_str_plain_supports_stddev );

    // Actual function code.
    _python_var___module__.assign0( _python_str_plain_backends );
    _python_var_allows_group_by_pk.assign0( Py_False );
    _python_var_needs_datetime_string_cast.assign0( Py_True );
    _python_var_empty_fetchmany_value.assign1( PyList_New( 0 ) );
    _python_var_update_can_self_select.assign0( Py_True );
    _python_var_interprets_empty_strings_as_nulls.assign0( Py_False );
    _python_var_ignores_nulls_in_unique_constraints.assign0( Py_True );
    _python_var_can_use_chunked_reads.assign0( Py_True );
    _python_var_can_return_id_from_insert.assign0( Py_False );
    _python_var_has_bulk_insert.assign0( Py_False );
    _python_var_uses_savepoints.assign0( Py_False );
    _python_var_can_combine_inserts_with_and_without_auto_increment_pk.assign0( Py_False );
    _python_var_related_fields_match_type.assign0( Py_False );
    _python_var_allow_sliced_subqueries.assign0( Py_True );
    _python_var_has_select_for_update.assign0( Py_False );
    _python_var_has_select_for_update_nowait.assign0( Py_False );
    _python_var_supports_select_related.assign0( Py_True );
    _python_var_test_db_allows_multiple_connections.assign0( Py_True );
    _python_var_supports_unspecified_pk.assign0( Py_False );
    _python_var_supports_forward_references.assign0( Py_True );
    _python_var_requires_rollback_on_dirty_transaction.assign0( Py_False );
    _python_var_supports_long_model_names.assign0( Py_True );
    _python_var_has_real_datatype.assign0( Py_False );
    _python_var_supports_subqueries_in_group_by.assign0( Py_True );
    _python_var_supports_bitwise_or.assign0( Py_True );
    _python_var_supports_microsecond_precision.assign0( Py_True );
    _python_var_supports_regex_backreferencing.assign0( Py_True );
    _python_var_supports_date_lookup_using_string.assign0( Py_True );
    _python_var_supports_timezones.assign0( Py_True );
    _python_var_has_zoneinfo_database.assign0( Py_True );
    _python_var_requires_explicit_null_ordering_when_grouping.assign0( Py_False );
    _python_var_supports_1000_query_parameters.assign0( Py_True );
    _python_var_allows_primary_key_0.assign0( Py_True );
    _python_var_can_defer_constraint_checks.assign0( Py_False );
    _python_var_supports_mixed_date_datetime_comparisons.assign0( Py_True );
    _python_var_supports_tablespaces.assign0( Py_False );
    _python_var_supports_sequence_reset.assign0( Py_True );
    _python_var_can_introspect_foreign_keys.assign0( Py_True );
    _python_var_can_distinct_on_fields.assign0( Py_False );
    _python_var_autocommits_when_autocommit_is_off.assign0( Py_False );
    _python_var___init__.assign1( MAKE_FUNCTION_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  ) );
    static PyFrameObject *frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends ) )
    {
        if ( frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for class_2_BaseDatabaseFeatures_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
        }

        frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends = MAKE_FRAME( _codeobj_ace54eaaead472ab01635c3b984bd445, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 610 );
        _python_var_supports_transactions.assign1( CALL_FUNCTION_WITH_ARGS( _mvar_django__db__backends_cached_property.asObject0(), PyObjectTemporary( MAKE_FUNCTION_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  ) ).asObject() ) );
        frame_guard.setLineNumber( 631 );
        _python_var_supports_stddev.assign1( CALL_FUNCTION_WITH_ARGS( _mvar_django__db__backends_cached_property.asObject0(), PyObjectTemporary( MAKE_FUNCTION_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  ) ).asObject() ) );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_supports_stddev.updateLocalsDict( _python_var_supports_transactions.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var_autocommits_when_autocommit_is_off.updateLocalsDict( _python_var_can_distinct_on_fields.updateLocalsDict( _python_var_can_introspect_foreign_keys.updateLocalsDict( _python_var_supports_sequence_reset.updateLocalsDict( _python_var_supports_tablespaces.updateLocalsDict( _python_var_supports_mixed_date_datetime_comparisons.updateLocalsDict( _python_var_can_defer_constraint_checks.updateLocalsDict( _python_var_allows_primary_key_0.updateLocalsDict( _python_var_supports_1000_query_parameters.updateLocalsDict( _python_var_requires_explicit_null_ordering_when_grouping.updateLocalsDict( _python_var_has_zoneinfo_database.updateLocalsDict( _python_var_supports_timezones.updateLocalsDict( _python_var_supports_date_lookup_using_string.updateLocalsDict( _python_var_supports_regex_backreferencing.updateLocalsDict( _python_var_supports_microsecond_precision.updateLocalsDict( _python_var_supports_bitwise_or.updateLocalsDict( _python_var_supports_subqueries_in_group_by.updateLocalsDict( _python_var_has_real_datatype.updateLocalsDict( _python_var_supports_long_model_names.updateLocalsDict( _python_var_requires_rollback_on_dirty_transaction.updateLocalsDict( _python_var_supports_forward_references.updateLocalsDict( _python_var_supports_unspecified_pk.updateLocalsDict( _python_var_test_db_allows_multiple_connections.updateLocalsDict( _python_var_supports_select_related.updateLocalsDict( _python_var_has_select_for_update_nowait.updateLocalsDict( _python_var_has_select_for_update.updateLocalsDict( _python_var_allow_sliced_subqueries.updateLocalsDict( _python_var_related_fields_match_type.updateLocalsDict( _python_var_can_combine_inserts_with_and_without_auto_increment_pk.updateLocalsDict( _python_var_uses_savepoints.updateLocalsDict( _python_var_has_bulk_insert.updateLocalsDict( _python_var_can_return_id_from_insert.updateLocalsDict( _python_var_can_use_chunked_reads.updateLocalsDict( _python_var_ignores_nulls_in_unique_constraints.updateLocalsDict( _python_var_interprets_empty_strings_as_nulls.updateLocalsDict( _python_var_update_can_self_select.updateLocalsDict( _python_var_empty_fetchmany_value.updateLocalsDict( _python_var_needs_datetime_string_cast.updateLocalsDict( _python_var_allows_group_by_pk.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends )
        {
           Py_DECREF( frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
           frame_class_2_BaseDatabaseFeatures_of_module_django__db__backends = NULL;
        }

        throw;
    }
    return _python_var_supports_stddev.updateLocalsDict( _python_var_supports_transactions.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var_autocommits_when_autocommit_is_off.updateLocalsDict( _python_var_can_distinct_on_fields.updateLocalsDict( _python_var_can_introspect_foreign_keys.updateLocalsDict( _python_var_supports_sequence_reset.updateLocalsDict( _python_var_supports_tablespaces.updateLocalsDict( _python_var_supports_mixed_date_datetime_comparisons.updateLocalsDict( _python_var_can_defer_constraint_checks.updateLocalsDict( _python_var_allows_primary_key_0.updateLocalsDict( _python_var_supports_1000_query_parameters.updateLocalsDict( _python_var_requires_explicit_null_ordering_when_grouping.updateLocalsDict( _python_var_has_zoneinfo_database.updateLocalsDict( _python_var_supports_timezones.updateLocalsDict( _python_var_supports_date_lookup_using_string.updateLocalsDict( _python_var_supports_regex_backreferencing.updateLocalsDict( _python_var_supports_microsecond_precision.updateLocalsDict( _python_var_supports_bitwise_or.updateLocalsDict( _python_var_supports_subqueries_in_group_by.updateLocalsDict( _python_var_has_real_datatype.updateLocalsDict( _python_var_supports_long_model_names.updateLocalsDict( _python_var_requires_rollback_on_dirty_transaction.updateLocalsDict( _python_var_supports_forward_references.updateLocalsDict( _python_var_supports_unspecified_pk.updateLocalsDict( _python_var_test_db_allows_multiple_connections.updateLocalsDict( _python_var_supports_select_related.updateLocalsDict( _python_var_has_select_for_update_nowait.updateLocalsDict( _python_var_has_select_for_update.updateLocalsDict( _python_var_allow_sliced_subqueries.updateLocalsDict( _python_var_related_fields_match_type.updateLocalsDict( _python_var_can_combine_inserts_with_and_without_auto_increment_pk.updateLocalsDict( _python_var_uses_savepoints.updateLocalsDict( _python_var_has_bulk_insert.updateLocalsDict( _python_var_can_return_id_from_insert.updateLocalsDict( _python_var_can_use_chunked_reads.updateLocalsDict( _python_var_ignores_nulls_in_unique_constraints.updateLocalsDict( _python_var_interprets_empty_strings_as_nulls.updateLocalsDict( _python_var_update_can_self_select.updateLocalsDict( _python_var_empty_fetchmany_value.updateLocalsDict( _python_var_needs_datetime_string_cast.updateLocalsDict( _python_var_allows_group_by_pk.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) );
}


static PyObject *impl_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_connection )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_connection( _python_str_plain_connection, _python_par_connection );

    // Actual function code.
    static PyFrameObject *frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends ) )
    {
        if ( frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
        }

        frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = MAKE_FRAME( _codeobj_02846dab0c1846b289b096934185fb93, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 608 );
        {
                PyObject *tmp_identifier = _python_var_connection.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_connection );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_connection.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
           frame_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_connection = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__init__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_connection == key )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_connection, key ) )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__init__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__init__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_connection != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
             goto error_exit;
         }

        _python_par_connection = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, _python_par_self, _python_par_connection );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_connection );

    return NULL;
}

static PyObject *dparse_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalVariable _python_var_cursor( _python_str_plain_cursor );
    PyObjectLocalVariable _python_var_count( _python_str_plain_count );

    // Actual function code.
    static PyFrameObject *frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends ) )
    {
        if ( frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
        }

        frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = MAKE_FRAME( _codeobj_70e43d0b8b48f51645e968e54e0404fb, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 613 );
        PythonExceptionKeeper _caught_1;


        try
        {
            frame_guard.setLineNumber( 617 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_enter_transaction_management ) ).asObject() ) );
            frame_guard.setLineNumber( 618 );
            _python_var_cursor.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_cursor ) ).asObject() ) );
            frame_guard.setLineNumber( 619 );
            DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_cursor.asObject(), _python_str_plain_execute ) ).asObject(), _python_str_digest_95be7b58d9f6ac714f7f06e768468cba ) );
            frame_guard.setLineNumber( 620 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_commit ) ).asObject() ) );
            frame_guard.setLineNumber( 621 );
            DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_cursor.asObject(), _python_str_plain_execute ) ).asObject(), _python_str_digest_b09a67f62e45f6e498dd811192e12507 ) );
            frame_guard.setLineNumber( 622 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_rollback ) ).asObject() ) );
            frame_guard.setLineNumber( 623 );
            DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_cursor.asObject(), _python_str_plain_execute ) ).asObject(), _python_str_digest_4a09d5b0c0f0bdb04f913ed449a2a5e2 ) );
            {
                frame_guard.setLineNumber( 624 );
                PyObjectTemporary _python_tmp_source_iter( MAKE_ITERATOR( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_cursor.asObject(), _python_str_plain_fetchone ) ).asObject() ) ).asObject() ) );
                PyObjectTemporary _python_tmp_element_1( UNPACK_NEXT( _python_tmp_source_iter.asObject(), 0 ) );
                UNPACK_ITERATOR_CHECK( _python_tmp_source_iter.asObject(), 1 );
                _python_var_count.assign0( _python_tmp_element_1.asObject() );
            }
            frame_guard.setLineNumber( 625 );
            DECREASE_REFCOUNT( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_cursor.asObject(), _python_str_plain_execute ) ).asObject(), _python_str_digest_110861008f57bb5c3d879bd01013a9eb ) );
            frame_guard.setLineNumber( 626 );
            DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_commit ) ).asObject() ) );
        }
        catch ( PythonException &_exception )
        {
            if ( !_exception.hasTraceback() )
            {
                _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
            }
            else
            {
                _exception.addTraceback( frame_guard.getFrame0() );
            }

            _caught_1.save( _exception );

#if PYTHON_VERSION >= 300
            frame_guard.preserveExistingException();

            _exception.toExceptionHandler();
#endif
        }

        // Final code:
        frame_guard.setLineNumber( 628 );
        DECREASE_REFCOUNT( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_leave_transaction_management ) ).asObject() ) );
        _caught_1.rethrow();
        frame_guard.setLineNumber( 629 );
        return RICH_COMPARE_EQ( _python_var_count.asObject(), _python_int_0 );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( _python_var_count.updateLocalsDict( _python_var_cursor.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
           frame_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "supports_transactions() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "supports_transactions() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "supports_transactions() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "supports_transactions() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "supports_transactions() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "supports_transactions() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "supports_transactions() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "supports_transactions() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "supports_transactions() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "supports_transactions() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "supports_transactions() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "supports_transactions() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "supports_transactions() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "supports_transactions() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "supports_transactions() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "supports_transactions() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "supports_transactions() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalVariable _python_var_StdDevPop( _python_str_plain_StdDevPop );

    // Actual function code.
    static PyFrameObject *frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends ) )
    {
        if ( frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
        }

        frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = MAKE_FRAME( _codeobj_3eec6de8e6560d9ca3138b7974f3d129, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends ) == 2 ); // Frame stack
        {
            frame_guard.setLineNumber( 634 );
            PyObjectTemporary _python_tmp_bases( MAKE_TUPLE1( LOOKUP_BUILTIN( _python_str_plain_object ) ) );
            PyObjectTemporary _python_tmp_class_dict( impl_class_1_StdDevPop_of_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  ) );
            PyObjectTemporary _python_tmp_metaclass( ( SEQUENCE_CONTAINS_BOOL( _python_str_plain___metaclass__, _python_tmp_class_dict.asObject() ) ? DICT_GET_ITEM( _python_tmp_class_dict.asObject(), _python_str_plain___metaclass__ ) : SELECT_METACLASS( _python_tmp_bases.asObject(), ( _mvar_django__db__backends___metaclass__.isInitialized( false ) ? _mvar_django__db__backends___metaclass__.asObject0() : NULL ) ) ) );
            PyObject *_tmp_python_tmp_class;
            {
                PyObjectTempKeeper0 call1;
                PyObjectTempKeeper0 call3;
                _tmp_python_tmp_class = ( call1.assign( _python_tmp_metaclass.asObject() ), call3.assign( _python_tmp_bases.asObject() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_str_plain_StdDevPop, call3.asObject0(), _python_tmp_class_dict.asObject() ) );
            }
            PyObjectTemporary _python_tmp_class( _tmp_python_tmp_class );
            _python_var_StdDevPop.assign0( _python_tmp_class.asObject() );
        }
        frame_guard.setLineNumber( 637 );
        try
        {
            frame_guard.setLineNumber( 638 );
            {
                PyObjectTempKeeper1 call5;
                DECREASE_REFCOUNT( ( call5.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_ops ) ).asObject(), _python_str_plain_check_aggregate_support ) ), CALL_FUNCTION_WITH_ARGS( call5.asObject0(), PyObjectTemporary( CALL_FUNCTION_NO_ARGS( _python_var_StdDevPop.asObject() ) ).asObject() ) ) );
            }
            return INCREASE_REFCOUNT( Py_True );
        }
        catch ( PythonException &_exception )
        {
            if ( !_exception.hasTraceback() )
            {
                _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
            }
            else
            {
                _exception.addTraceback( frame_guard.getFrame0() );
            }

            frame_guard.preserveExistingException();

#if PYTHON_VERSION >= 300
            ExceptionRestorerFrameGuard restorer( &frame_guard );
#endif
            _exception.toExceptionHandler();

            if ( _exception.matches( PyExc_NotImplementedError ) )
            {
                frame_guard.detachFrame();
                return INCREASE_REFCOUNT( Py_False );
            }
            else
            {
                PyTracebackObject *tb = _exception.getTraceback();
                frame_guard.setLineNumber( tb->tb_lineno );
                _exception.setTraceback( tb->tb_next );
                tb->tb_next = NULL;

                throw;
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( _python_var_StdDevPop.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends );
           frame_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "supports_stddev() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "supports_stddev() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "supports_stddev() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "supports_stddev() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "supports_stddev() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "supports_stddev() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "supports_stddev() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "supports_stddev() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "supports_stddev() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "supports_stddev() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "supports_stddev() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "supports_stddev() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "supports_stddev() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "supports_stddev() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "supports_stddev() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "supports_stddev() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "supports_stddev() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



NUITKA_LOCAL_MODULE PyObject *impl_class_1_StdDevPop_of_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalVariable _python_var___module__( _python_str_plain___module__ );
    PyObjectLocalVariable _python_var_sql_function( _python_str_plain_sql_function );

    // Actual function code.
    _python_var___module__.assign0( _python_str_plain_backends );
    _python_var_sql_function.assign0( _python_str_plain_STDDEV_POP );
    return _python_var_sql_function.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) );
}


NUITKA_LOCAL_MODULE PyObject *impl_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalVariable _python_var___module__( _python_str_plain___module__ );
    PyObjectLocalVariable _python_var___doc__( _python_str_plain___doc__ );
    PyObjectLocalVariable _python_var_compiler_module( _python_str_plain_compiler_module );
    PyObjectLocalVariable _python_var___init__( _python_str_plain___init__ );
    PyObjectLocalVariable _python_var_autoinc_sql( _python_str_plain_autoinc_sql );
    PyObjectLocalVariable _python_var_bulk_batch_size( _python_str_plain_bulk_batch_size );
    PyObjectLocalVariable _python_var_cache_key_culling_sql( _python_str_plain_cache_key_culling_sql );
    PyObjectLocalVariable _python_var_date_extract_sql( _python_str_plain_date_extract_sql );
    PyObjectLocalVariable _python_var_date_interval_sql( _python_str_plain_date_interval_sql );
    PyObjectLocalVariable _python_var_date_trunc_sql( _python_str_plain_date_trunc_sql );
    PyObjectLocalVariable _python_var_datetime_cast_sql( _python_str_plain_datetime_cast_sql );
    PyObjectLocalVariable _python_var_datetime_extract_sql( _python_str_plain_datetime_extract_sql );
    PyObjectLocalVariable _python_var_datetime_trunc_sql( _python_str_plain_datetime_trunc_sql );
    PyObjectLocalVariable _python_var_deferrable_sql( _python_str_plain_deferrable_sql );
    PyObjectLocalVariable _python_var_distinct_sql( _python_str_plain_distinct_sql );
    PyObjectLocalVariable _python_var_drop_foreignkey_sql( _python_str_plain_drop_foreignkey_sql );
    PyObjectLocalVariable _python_var_drop_sequence_sql( _python_str_plain_drop_sequence_sql );
    PyObjectLocalVariable _python_var_fetch_returned_insert_id( _python_str_plain_fetch_returned_insert_id );
    PyObjectLocalVariable _python_var_field_cast_sql( _python_str_plain_field_cast_sql );
    PyObjectLocalVariable _python_var_force_no_ordering( _python_str_plain_force_no_ordering );
    PyObjectLocalVariable _python_var_for_update_sql( _python_str_plain_for_update_sql );
    PyObjectLocalVariable _python_var_fulltext_search_sql( _python_str_plain_fulltext_search_sql );
    PyObjectLocalVariable _python_var_last_executed_query( _python_str_plain_last_executed_query );
    PyObjectLocalVariable _python_var_last_insert_id( _python_str_plain_last_insert_id );
    PyObjectLocalVariable _python_var_lookup_cast( _python_str_plain_lookup_cast );
    PyObjectLocalVariable _python_var_max_in_list_size( _python_str_plain_max_in_list_size );
    PyObjectLocalVariable _python_var_max_name_length( _python_str_plain_max_name_length );
    PyObjectLocalVariable _python_var_no_limit_value( _python_str_plain_no_limit_value );
    PyObjectLocalVariable _python_var_pk_default_value( _python_str_plain_pk_default_value );
    PyObjectLocalVariable _python_var_process_clob( _python_str_plain_process_clob );
    PyObjectLocalVariable _python_var_return_insert_id( _python_str_plain_return_insert_id );
    PyObjectLocalVariable _python_var_compiler( _python_str_plain_compiler );
    PyObjectLocalVariable _python_var_quote_name( _python_str_plain_quote_name );
    PyObjectLocalVariable _python_var_random_function_sql( _python_str_plain_random_function_sql );
    PyObjectLocalVariable _python_var_regex_lookup( _python_str_plain_regex_lookup );
    PyObjectLocalVariable _python_var_savepoint_create_sql( _python_str_plain_savepoint_create_sql );
    PyObjectLocalVariable _python_var_savepoint_commit_sql( _python_str_plain_savepoint_commit_sql );
    PyObjectLocalVariable _python_var_savepoint_rollback_sql( _python_str_plain_savepoint_rollback_sql );
    PyObjectLocalVariable _python_var_set_time_zone_sql( _python_str_plain_set_time_zone_sql );
    PyObjectLocalVariable _python_var_sql_flush( _python_str_plain_sql_flush );
    PyObjectLocalVariable _python_var_sequence_reset_by_name_sql( _python_str_plain_sequence_reset_by_name_sql );
    PyObjectLocalVariable _python_var_sequence_reset_sql( _python_str_plain_sequence_reset_sql );
    PyObjectLocalVariable _python_var_start_transaction_sql( _python_str_plain_start_transaction_sql );
    PyObjectLocalVariable _python_var_end_transaction_sql( _python_str_plain_end_transaction_sql );
    PyObjectLocalVariable _python_var_tablespace_sql( _python_str_plain_tablespace_sql );
    PyObjectLocalVariable _python_var_prep_for_like_query( _python_str_plain_prep_for_like_query );
    PyObjectLocalVariable _python_var_prep_for_iexact_query( _python_str_plain_prep_for_iexact_query );
    PyObjectLocalVariable _python_var_validate_autopk_value( _python_str_plain_validate_autopk_value );
    PyObjectLocalVariable _python_var_value_to_db_date( _python_str_plain_value_to_db_date );
    PyObjectLocalVariable _python_var_value_to_db_datetime( _python_str_plain_value_to_db_datetime );
    PyObjectLocalVariable _python_var_value_to_db_time( _python_str_plain_value_to_db_time );
    PyObjectLocalVariable _python_var_value_to_db_decimal( _python_str_plain_value_to_db_decimal );
    PyObjectLocalVariable _python_var_year_lookup_bounds_for_date_field( _python_str_plain_year_lookup_bounds_for_date_field );
    PyObjectLocalVariable _python_var_year_lookup_bounds_for_datetime_field( _python_str_plain_year_lookup_bounds_for_datetime_field );
    PyObjectLocalVariable _python_var_convert_values( _python_str_plain_convert_values );
    PyObjectLocalVariable _python_var_check_aggregate_support( _python_str_plain_check_aggregate_support );
    PyObjectLocalVariable _python_var_combine_expression( _python_str_plain_combine_expression );
    PyObjectLocalVariable _python_var_modify_insert_params( _python_str_plain_modify_insert_params );

    // Actual function code.
    _python_var___module__.assign0( _python_str_plain_backends );
    _python_var___doc__.assign0( _python_str_digest_4d47dce686ebb63bb5a8b81d579288f1 );
    _python_var_compiler_module.assign0( _python_str_digest_08e768972e776d24c8e1ba7bbb8809e5 );
    _python_var___init__.assign1( MAKE_FUNCTION_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_autoinc_sql.assign1( MAKE_FUNCTION_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_bulk_batch_size.assign1( MAKE_FUNCTION_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_cache_key_culling_sql.assign1( MAKE_FUNCTION_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_date_extract_sql.assign1( MAKE_FUNCTION_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_date_interval_sql.assign1( MAKE_FUNCTION_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_date_trunc_sql.assign1( MAKE_FUNCTION_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_datetime_cast_sql.assign1( MAKE_FUNCTION_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_datetime_extract_sql.assign1( MAKE_FUNCTION_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_datetime_trunc_sql.assign1( MAKE_FUNCTION_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_deferrable_sql.assign1( MAKE_FUNCTION_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_distinct_sql.assign1( MAKE_FUNCTION_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_drop_foreignkey_sql.assign1( MAKE_FUNCTION_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_drop_sequence_sql.assign1( MAKE_FUNCTION_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_fetch_returned_insert_id.assign1( MAKE_FUNCTION_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_field_cast_sql.assign1( MAKE_FUNCTION_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_force_no_ordering.assign1( MAKE_FUNCTION_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_for_update_sql.assign1( MAKE_FUNCTION_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_fulltext_search_sql.assign1( MAKE_FUNCTION_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_last_executed_query.assign1( MAKE_FUNCTION_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_last_insert_id.assign1( MAKE_FUNCTION_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_lookup_cast.assign1( MAKE_FUNCTION_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_max_in_list_size.assign1( MAKE_FUNCTION_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_max_name_length.assign1( MAKE_FUNCTION_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_no_limit_value.assign1( MAKE_FUNCTION_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_pk_default_value.assign1( MAKE_FUNCTION_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_process_clob.assign1( MAKE_FUNCTION_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_return_insert_id.assign1( MAKE_FUNCTION_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_compiler.assign1( MAKE_FUNCTION_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_quote_name.assign1( MAKE_FUNCTION_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_random_function_sql.assign1( MAKE_FUNCTION_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_regex_lookup.assign1( MAKE_FUNCTION_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_savepoint_create_sql.assign1( MAKE_FUNCTION_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_savepoint_commit_sql.assign1( MAKE_FUNCTION_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_savepoint_rollback_sql.assign1( MAKE_FUNCTION_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_set_time_zone_sql.assign1( MAKE_FUNCTION_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_sql_flush.assign1( MAKE_FUNCTION_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_sequence_reset_by_name_sql.assign1( MAKE_FUNCTION_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_sequence_reset_sql.assign1( MAKE_FUNCTION_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_start_transaction_sql.assign1( MAKE_FUNCTION_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_end_transaction_sql.assign1( MAKE_FUNCTION_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_tablespace_sql.assign1( MAKE_FUNCTION_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_prep_for_like_query.assign1( MAKE_FUNCTION_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    static PyFrameObject *frame_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_48d080466609a766c0e4a10855bcf08a, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1020 );
        _python_var_prep_for_iexact_query.assign0( _python_var_prep_for_like_query.asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_modify_insert_params.updateLocalsDict( _python_var_combine_expression.updateLocalsDict( _python_var_check_aggregate_support.updateLocalsDict( _python_var_convert_values.updateLocalsDict( _python_var_year_lookup_bounds_for_datetime_field.updateLocalsDict( _python_var_year_lookup_bounds_for_date_field.updateLocalsDict( _python_var_value_to_db_decimal.updateLocalsDict( _python_var_value_to_db_time.updateLocalsDict( _python_var_value_to_db_datetime.updateLocalsDict( _python_var_value_to_db_date.updateLocalsDict( _python_var_validate_autopk_value.updateLocalsDict( _python_var_prep_for_iexact_query.updateLocalsDict( _python_var_prep_for_like_query.updateLocalsDict( _python_var_tablespace_sql.updateLocalsDict( _python_var_end_transaction_sql.updateLocalsDict( _python_var_start_transaction_sql.updateLocalsDict( _python_var_sequence_reset_sql.updateLocalsDict( _python_var_sequence_reset_by_name_sql.updateLocalsDict( _python_var_sql_flush.updateLocalsDict( _python_var_set_time_zone_sql.updateLocalsDict( _python_var_savepoint_rollback_sql.updateLocalsDict( _python_var_savepoint_commit_sql.updateLocalsDict( _python_var_savepoint_create_sql.updateLocalsDict( _python_var_regex_lookup.updateLocalsDict( _python_var_random_function_sql.updateLocalsDict( _python_var_quote_name.updateLocalsDict( _python_var_compiler.updateLocalsDict( _python_var_return_insert_id.updateLocalsDict( _python_var_process_clob.updateLocalsDict( _python_var_pk_default_value.updateLocalsDict( _python_var_no_limit_value.updateLocalsDict( _python_var_max_name_length.updateLocalsDict( _python_var_max_in_list_size.updateLocalsDict( _python_var_lookup_cast.updateLocalsDict( _python_var_last_insert_id.updateLocalsDict( _python_var_last_executed_query.updateLocalsDict( _python_var_fulltext_search_sql.updateLocalsDict( _python_var_for_update_sql.updateLocalsDict( _python_var_force_no_ordering.updateLocalsDict( _python_var_field_cast_sql.updateLocalsDict( _python_var_fetch_returned_insert_id.updateLocalsDict( _python_var_drop_sequence_sql.updateLocalsDict( _python_var_drop_foreignkey_sql.updateLocalsDict( _python_var_distinct_sql.updateLocalsDict( _python_var_deferrable_sql.updateLocalsDict( _python_var_datetime_trunc_sql.updateLocalsDict( _python_var_datetime_extract_sql.updateLocalsDict( _python_var_datetime_cast_sql.updateLocalsDict( _python_var_date_trunc_sql.updateLocalsDict( _python_var_date_interval_sql.updateLocalsDict( _python_var_date_extract_sql.updateLocalsDict( _python_var_cache_key_culling_sql.updateLocalsDict( _python_var_bulk_batch_size.updateLocalsDict( _python_var_autoinc_sql.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var_compiler_module.updateLocalsDict( _python_var___doc__.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        throw;
    }
    _python_var_validate_autopk_value.assign1( MAKE_FUNCTION_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_value_to_db_date.assign1( MAKE_FUNCTION_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_value_to_db_datetime.assign1( MAKE_FUNCTION_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_value_to_db_time.assign1( MAKE_FUNCTION_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_value_to_db_decimal.assign1( MAKE_FUNCTION_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_year_lookup_bounds_for_date_field.assign1( MAKE_FUNCTION_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_year_lookup_bounds_for_datetime_field.assign1( MAKE_FUNCTION_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_convert_values.assign1( MAKE_FUNCTION_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_check_aggregate_support.assign1( MAKE_FUNCTION_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_combine_expression.assign1( MAKE_FUNCTION_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    _python_var_modify_insert_params.assign1( MAKE_FUNCTION_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
    return _python_var_modify_insert_params.updateLocalsDict( _python_var_combine_expression.updateLocalsDict( _python_var_check_aggregate_support.updateLocalsDict( _python_var_convert_values.updateLocalsDict( _python_var_year_lookup_bounds_for_datetime_field.updateLocalsDict( _python_var_year_lookup_bounds_for_date_field.updateLocalsDict( _python_var_value_to_db_decimal.updateLocalsDict( _python_var_value_to_db_time.updateLocalsDict( _python_var_value_to_db_datetime.updateLocalsDict( _python_var_value_to_db_date.updateLocalsDict( _python_var_validate_autopk_value.updateLocalsDict( _python_var_prep_for_iexact_query.updateLocalsDict( _python_var_prep_for_like_query.updateLocalsDict( _python_var_tablespace_sql.updateLocalsDict( _python_var_end_transaction_sql.updateLocalsDict( _python_var_start_transaction_sql.updateLocalsDict( _python_var_sequence_reset_sql.updateLocalsDict( _python_var_sequence_reset_by_name_sql.updateLocalsDict( _python_var_sql_flush.updateLocalsDict( _python_var_set_time_zone_sql.updateLocalsDict( _python_var_savepoint_rollback_sql.updateLocalsDict( _python_var_savepoint_commit_sql.updateLocalsDict( _python_var_savepoint_create_sql.updateLocalsDict( _python_var_regex_lookup.updateLocalsDict( _python_var_random_function_sql.updateLocalsDict( _python_var_quote_name.updateLocalsDict( _python_var_compiler.updateLocalsDict( _python_var_return_insert_id.updateLocalsDict( _python_var_process_clob.updateLocalsDict( _python_var_pk_default_value.updateLocalsDict( _python_var_no_limit_value.updateLocalsDict( _python_var_max_name_length.updateLocalsDict( _python_var_max_in_list_size.updateLocalsDict( _python_var_lookup_cast.updateLocalsDict( _python_var_last_insert_id.updateLocalsDict( _python_var_last_executed_query.updateLocalsDict( _python_var_fulltext_search_sql.updateLocalsDict( _python_var_for_update_sql.updateLocalsDict( _python_var_force_no_ordering.updateLocalsDict( _python_var_field_cast_sql.updateLocalsDict( _python_var_fetch_returned_insert_id.updateLocalsDict( _python_var_drop_sequence_sql.updateLocalsDict( _python_var_drop_foreignkey_sql.updateLocalsDict( _python_var_distinct_sql.updateLocalsDict( _python_var_deferrable_sql.updateLocalsDict( _python_var_datetime_trunc_sql.updateLocalsDict( _python_var_datetime_extract_sql.updateLocalsDict( _python_var_datetime_cast_sql.updateLocalsDict( _python_var_date_trunc_sql.updateLocalsDict( _python_var_date_interval_sql.updateLocalsDict( _python_var_date_extract_sql.updateLocalsDict( _python_var_cache_key_culling_sql.updateLocalsDict( _python_var_bulk_batch_size.updateLocalsDict( _python_var_autoinc_sql.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var_compiler_module.updateLocalsDict( _python_var___doc__.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) );
}


static PyObject *impl_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_connection )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_connection( _python_str_plain_connection, _python_par_connection );

    // Actual function code.
    static PyFrameObject *frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_6a99f00dea99dbeeaefed77440a3af8b, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 653 );
        {
                PyObject *tmp_identifier = _python_var_connection.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_connection );
        }
        frame_guard.setLineNumber( 654 );
        SET_ATTRIBUTE( Py_None, _python_var_self.asObject(), _python_str_plain__cache );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_connection.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_connection = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__init__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_connection == key )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_connection, key ) )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__init__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__init__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_connection != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
             goto error_exit;
         }

        _python_par_connection = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_connection );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_connection );

    return NULL;
}

static PyObject *dparse_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_table, PyObject *_python_par_column )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_table( _python_str_plain_table, _python_par_table );
    PyObjectLocalParameterVariableNoDel _python_var_column( _python_str_plain_column, _python_par_column );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_table = NULL;
    PyObject *_python_par_column = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "autoinc_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_table == key )
            {
                if (unlikely( _python_par_table ))
                {
                    PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'table'" );
                    goto error_exit;
                }

                _python_par_table = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_column == key )
            {
                if (unlikely( _python_par_column ))
                {
                    PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'column'" );
                    goto error_exit;
                }

                _python_par_column = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_table, key ) )
            {
                if (unlikely( _python_par_table ))
                {
                    PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'table'" );
                    goto error_exit;
                }

                _python_par_table = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_column, key ) )
            {
                if (unlikely( _python_par_column ))
                {
                    PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'column'" );
                    goto error_exit;
                }

                _python_par_column = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "autoinc_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "autoinc_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "autoinc_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "autoinc_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "autoinc_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "autoinc_sql() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "autoinc_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "autoinc_sql() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "autoinc_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "autoinc_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "autoinc_sql() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "autoinc_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "autoinc_sql() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_table != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'table'" );
             goto error_exit;
         }

        _python_par_table = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_column != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "autoinc_sql() got multiple values for keyword argument 'column'" );
             goto error_exit;
         }

        _python_par_column = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_table, _python_par_column );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_table );
    Py_XDECREF( _python_par_column );

    return NULL;
}

static PyObject *dparse_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_fields, PyObject *_python_par_objs )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_fields( _python_str_plain_fields, _python_par_fields );
    PyObjectLocalParameterVariableNoDel _python_var_objs( _python_str_plain_objs, _python_par_objs );

    // Actual function code.
    static PyFrameObject *frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_e84ed2df3bc6f767e025bec789b2e67e, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 671 );
        return BUILTIN_LEN( _python_var_objs.asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_objs.updateLocalsDict( _python_var_fields.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_fields = NULL;
    PyObject *_python_par_objs = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "bulk_batch_size() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_fields == key )
            {
                if (unlikely( _python_par_fields ))
                {
                    PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'fields'" );
                    goto error_exit;
                }

                _python_par_fields = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_objs == key )
            {
                if (unlikely( _python_par_objs ))
                {
                    PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'objs'" );
                    goto error_exit;
                }

                _python_par_objs = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_fields, key ) )
            {
                if (unlikely( _python_par_fields ))
                {
                    PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'fields'" );
                    goto error_exit;
                }

                _python_par_fields = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_objs, key ) )
            {
                if (unlikely( _python_par_objs ))
                {
                    PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'objs'" );
                    goto error_exit;
                }

                _python_par_objs = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "bulk_batch_size() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "bulk_batch_size() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_fields != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'fields'" );
             goto error_exit;
         }

        _python_par_fields = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_objs != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "bulk_batch_size() got multiple values for keyword argument 'objs'" );
             goto error_exit;
         }

        _python_par_objs = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_fields, _python_par_objs );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_fields );
    Py_XDECREF( _python_par_objs );

    return NULL;
}

static PyObject *dparse_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_digest_3fadf4e3a479c1f9e6a3a690b8b6818d );
}
static PyObject *fparse_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "cache_key_culling_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "cache_key_culling_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_lookup_type, PyObject *_python_par_field_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_lookup_type( _python_str_plain_lookup_type, _python_par_lookup_type );
    PyObjectLocalParameterVariableNoDel _python_var_field_name( _python_str_plain_field_name, _python_par_field_name );

    // Actual function code.
    static PyFrameObject *frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_394b1b895b503510d6a8250e3b9ef11f, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 688 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, _python_tuple_empty ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_field_name.updateLocalsDict( _python_var_lookup_type.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_lookup_type = NULL;
    PyObject *_python_par_field_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "date_extract_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_lookup_type == key )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_field_name == key )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_lookup_type, key ) )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_field_name, key ) )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "date_extract_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "date_extract_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "date_extract_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "date_extract_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "date_extract_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "date_extract_sql() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "date_extract_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "date_extract_sql() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "date_extract_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "date_extract_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "date_extract_sql() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "date_extract_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "date_extract_sql() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_lookup_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'lookup_type'" );
             goto error_exit;
         }

        _python_par_lookup_type = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_field_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_extract_sql() got multiple values for keyword argument 'field_name'" );
             goto error_exit;
         }

        _python_par_field_name = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_lookup_type, _python_par_field_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_lookup_type );
    Py_XDECREF( _python_par_field_name );

    return NULL;
}

static PyObject *dparse_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sql, PyObject *_python_par_connector, PyObject *_python_par_timedelta )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sql( _python_str_plain_sql, _python_par_sql );
    PyObjectLocalParameterVariableNoDel _python_var_connector( _python_str_plain_connector, _python_par_connector );
    PyObjectLocalParameterVariableNoDel _python_var_timedelta( _python_str_plain_timedelta, _python_par_timedelta );

    // Actual function code.
    static PyFrameObject *frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_92254d74c78bf1151343d5a6fdd49033, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 694 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, _python_tuple_empty ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_timedelta.updateLocalsDict( _python_var_connector.updateLocalsDict( _python_var_sql.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sql = NULL;
    PyObject *_python_par_connector = NULL;
    PyObject *_python_par_timedelta = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "date_interval_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sql == key )
            {
                if (unlikely( _python_par_sql ))
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'sql'" );
                    goto error_exit;
                }

                _python_par_sql = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_connector == key )
            {
                if (unlikely( _python_par_connector ))
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'connector'" );
                    goto error_exit;
                }

                _python_par_connector = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_timedelta == key )
            {
                if (unlikely( _python_par_timedelta ))
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'timedelta'" );
                    goto error_exit;
                }

                _python_par_timedelta = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sql, key ) )
            {
                if (unlikely( _python_par_sql ))
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'sql'" );
                    goto error_exit;
                }

                _python_par_sql = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_connector, key ) )
            {
                if (unlikely( _python_par_connector ))
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'connector'" );
                    goto error_exit;
                }

                _python_par_connector = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_timedelta, key ) )
            {
                if (unlikely( _python_par_timedelta ))
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'timedelta'" );
                    goto error_exit;
                }

                _python_par_timedelta = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "date_interval_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 4 ))
    {
        if ( 4 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "date_interval_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "date_interval_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "date_interval_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "date_interval_sql() takes exactly %d arguments (%zd given)", 4, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "date_interval_sql() takes exactly %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "date_interval_sql() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#else
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "date_interval_sql() takes %d positional arguments but %zd were given", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "date_interval_sql() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 4 ))
    {
        if ( 4 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "date_interval_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "date_interval_sql() takes exactly %d non-keyword arguments (%zd given)", 4, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 4 == 4 )
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() takes exactly %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "date_interval_sql() takes at least %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 4 ? args_given : 4;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sql != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'sql'" );
             goto error_exit;
         }

        _python_par_sql = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_connector != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'connector'" );
             goto error_exit;
         }

        _python_par_connector = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_timedelta != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_interval_sql() got multiple values for keyword argument 'timedelta'" );
             goto error_exit;
         }

        _python_par_timedelta = INCREASE_REFCOUNT( args[ 3 ] );
    }


    return impl_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_sql, _python_par_connector, _python_par_timedelta );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sql );
    Py_XDECREF( _python_par_connector );
    Py_XDECREF( _python_par_timedelta );

    return NULL;
}

static PyObject *dparse_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 4)
    {
        return impl_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_lookup_type, PyObject *_python_par_field_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_lookup_type( _python_str_plain_lookup_type, _python_par_lookup_type );
    PyObjectLocalParameterVariableNoDel _python_var_field_name( _python_str_plain_field_name, _python_par_field_name );

    // Actual function code.
    static PyFrameObject *frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_ac08f3c67b2503e5bc57a154cf12298c, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 702 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, _python_tuple_empty ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_field_name.updateLocalsDict( _python_var_lookup_type.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_lookup_type = NULL;
    PyObject *_python_par_field_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "date_trunc_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_lookup_type == key )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_field_name == key )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_lookup_type, key ) )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_field_name, key ) )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "date_trunc_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "date_trunc_sql() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_lookup_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'lookup_type'" );
             goto error_exit;
         }

        _python_par_lookup_type = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_field_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "date_trunc_sql() got multiple values for keyword argument 'field_name'" );
             goto error_exit;
         }

        _python_par_field_name = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_lookup_type, _python_par_field_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_lookup_type );
    Py_XDECREF( _python_par_field_name );

    return NULL;
}

static PyObject *dparse_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_digest_1c481aa99d081c32182011a758f73d33 );
}
static PyObject *fparse_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "datetime_cast_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_cast_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_cast_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "datetime_cast_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "datetime_cast_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_cast_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_lookup_type, PyObject *_python_par_field_name, PyObject *_python_par_tzname )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_lookup_type( _python_str_plain_lookup_type, _python_par_lookup_type );
    PyObjectLocalParameterVariableNoDel _python_var_field_name( _python_str_plain_field_name, _python_par_field_name );
    PyObjectLocalParameterVariableNoDel _python_var_tzname( _python_str_plain_tzname, _python_par_tzname );

    // Actual function code.
    static PyFrameObject *frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_c4254974ffce4639bd91d4b58814332f, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 719 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, _python_tuple_empty ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_tzname.updateLocalsDict( _python_var_field_name.updateLocalsDict( _python_var_lookup_type.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_lookup_type = NULL;
    PyObject *_python_par_field_name = NULL;
    PyObject *_python_par_tzname = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "datetime_extract_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_lookup_type == key )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_field_name == key )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_tzname == key )
            {
                if (unlikely( _python_par_tzname ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'tzname'" );
                    goto error_exit;
                }

                _python_par_tzname = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_lookup_type, key ) )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_field_name, key ) )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_tzname, key ) )
            {
                if (unlikely( _python_par_tzname ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'tzname'" );
                    goto error_exit;
                }

                _python_par_tzname = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "datetime_extract_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 4 ))
    {
        if ( 4 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes exactly %d arguments (%zd given)", 4, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes exactly %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#else
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes %d positional arguments but %zd were given", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 4 ))
    {
        if ( 4 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes exactly %d non-keyword arguments (%zd given)", 4, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 4 == 4 )
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes exactly %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "datetime_extract_sql() takes at least %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 4 ? args_given : 4;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_lookup_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'lookup_type'" );
             goto error_exit;
         }

        _python_par_lookup_type = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_field_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'field_name'" );
             goto error_exit;
         }

        _python_par_field_name = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_tzname != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_extract_sql() got multiple values for keyword argument 'tzname'" );
             goto error_exit;
         }

        _python_par_tzname = INCREASE_REFCOUNT( args[ 3 ] );
    }


    return impl_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_lookup_type, _python_par_field_name, _python_par_tzname );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_lookup_type );
    Py_XDECREF( _python_par_field_name );
    Py_XDECREF( _python_par_tzname );

    return NULL;
}

static PyObject *dparse_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 4)
    {
        return impl_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_lookup_type, PyObject *_python_par_field_name, PyObject *_python_par_tzname )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_lookup_type( _python_str_plain_lookup_type, _python_par_lookup_type );
    PyObjectLocalParameterVariableNoDel _python_var_field_name( _python_str_plain_field_name, _python_par_field_name );
    PyObjectLocalParameterVariableNoDel _python_var_tzname( _python_str_plain_tzname, _python_par_tzname );

    // Actual function code.
    static PyFrameObject *frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_09169b36c58f2d3b6695e7e432c031e9, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 728 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, _python_tuple_empty ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_tzname.updateLocalsDict( _python_var_field_name.updateLocalsDict( _python_var_lookup_type.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_lookup_type = NULL;
    PyObject *_python_par_field_name = NULL;
    PyObject *_python_par_tzname = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_lookup_type == key )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_field_name == key )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_tzname == key )
            {
                if (unlikely( _python_par_tzname ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'tzname'" );
                    goto error_exit;
                }

                _python_par_tzname = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_lookup_type, key ) )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_field_name, key ) )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_tzname, key ) )
            {
                if (unlikely( _python_par_tzname ))
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'tzname'" );
                    goto error_exit;
                }

                _python_par_tzname = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "datetime_trunc_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 4 ))
    {
        if ( 4 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes exactly %d arguments (%zd given)", 4, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes exactly %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#else
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes %d positional arguments but %zd were given", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 4 ))
    {
        if ( 4 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes exactly %d non-keyword arguments (%zd given)", 4, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 4 == 4 )
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes exactly %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() takes at least %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 4 ? args_given : 4;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_lookup_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'lookup_type'" );
             goto error_exit;
         }

        _python_par_lookup_type = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_field_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'field_name'" );
             goto error_exit;
         }

        _python_par_field_name = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_tzname != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "datetime_trunc_sql() got multiple values for keyword argument 'tzname'" );
             goto error_exit;
         }

        _python_par_tzname = INCREASE_REFCOUNT( args[ 3 ] );
    }


    return impl_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_lookup_type, _python_par_field_name, _python_par_tzname );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_lookup_type );
    Py_XDECREF( _python_par_field_name );
    Py_XDECREF( _python_par_tzname );

    return NULL;
}

static PyObject *dparse_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 4)
    {
        return impl_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_empty );
}
static PyObject *fparse_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "deferrable_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "deferrable_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "deferrable_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "deferrable_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "deferrable_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "deferrable_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "deferrable_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "deferrable_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "deferrable_sql() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "deferrable_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "deferrable_sql() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "deferrable_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "deferrable_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "deferrable_sql() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "deferrable_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "deferrable_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "deferrable_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_fields )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_fields( _python_str_plain_fields, _python_par_fields );

    // Actual function code.
    static PyFrameObject *frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_2ca7cb49e299b7712fffe89e6f824e6b, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 743 );
        if ( CHECK_IF_TRUE( _python_var_fields.asObject() ) )
        {
            frame_guard.setLineNumber( 744 );
            {
                    PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TUPLE1( _python_str_digest_0210e3ac89ccdf20eaa24e3fe5bf3d71 ) ).asObject() ) );
                    RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
            }
        }
        else
        {
            return INCREASE_REFCOUNT( _python_str_plain_DISTINCT );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_fields.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_fields = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "distinct_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "distinct_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_fields == key )
            {
                if (unlikely( _python_par_fields ))
                {
                    PyErr_Format( PyExc_TypeError, "distinct_sql() got multiple values for keyword argument 'fields'" );
                    goto error_exit;
                }

                _python_par_fields = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "distinct_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_fields, key ) )
            {
                if (unlikely( _python_par_fields ))
                {
                    PyErr_Format( PyExc_TypeError, "distinct_sql() got multiple values for keyword argument 'fields'" );
                    goto error_exit;
                }

                _python_par_fields = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "distinct_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "distinct_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "distinct_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "distinct_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "distinct_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "distinct_sql() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "distinct_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "distinct_sql() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "distinct_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "distinct_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "distinct_sql() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "distinct_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "distinct_sql() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "distinct_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_fields != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "distinct_sql() got multiple values for keyword argument 'fields'" );
             goto error_exit;
         }

        _python_par_fields = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_fields );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_fields );

    return NULL;
}

static PyObject *dparse_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_digest_69afa411c1de714ca9c73bf93b8e91ea );
}
static PyObject *fparse_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "drop_foreignkey_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "drop_foreignkey_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_table )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_table( _python_str_plain_table, _python_par_table );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_table = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "drop_sequence_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "drop_sequence_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_table == key )
            {
                if (unlikely( _python_par_table ))
                {
                    PyErr_Format( PyExc_TypeError, "drop_sequence_sql() got multiple values for keyword argument 'table'" );
                    goto error_exit;
                }

                _python_par_table = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "drop_sequence_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_table, key ) )
            {
                if (unlikely( _python_par_table ))
                {
                    PyErr_Format( PyExc_TypeError, "drop_sequence_sql() got multiple values for keyword argument 'table'" );
                    goto error_exit;
                }

                _python_par_table = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "drop_sequence_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "drop_sequence_sql() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "drop_sequence_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_table != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "drop_sequence_sql() got multiple values for keyword argument 'table'" );
             goto error_exit;
         }

        _python_par_table = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_table );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_table );

    return NULL;
}

static PyObject *dparse_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );

    // Actual function code.
    static PyFrameObject *frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_a8a419bd891b90451fbe260ae3eb5efc, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 767 );
        return LOOKUP_SUBSCRIPT_CONST( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_cursor.asObject(), _python_str_plain_fetchone ) ).asObject() ) ).asObject(), _python_int_0, 0 );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "fetch_returned_insert_id() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "fetch_returned_insert_id() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_cursor );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );

    return NULL;
}

static PyObject *dparse_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_db_type, PyObject *_python_par_internal_type )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_db_type( _python_str_plain_db_type, _python_par_db_type );
    PyObjectLocalParameterVariableNoDel _python_var_internal_type( _python_str_plain_internal_type, _python_par_internal_type );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_digest_1c481aa99d081c32182011a758f73d33 );
}
static PyObject *fparse_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_db_type = NULL;
    PyObject *_python_par_internal_type = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "field_cast_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_db_type == key )
            {
                if (unlikely( _python_par_db_type ))
                {
                    PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'db_type'" );
                    goto error_exit;
                }

                _python_par_db_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_internal_type == key )
            {
                if (unlikely( _python_par_internal_type ))
                {
                    PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'internal_type'" );
                    goto error_exit;
                }

                _python_par_internal_type = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_db_type, key ) )
            {
                if (unlikely( _python_par_db_type ))
                {
                    PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'db_type'" );
                    goto error_exit;
                }

                _python_par_db_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_internal_type, key ) )
            {
                if (unlikely( _python_par_internal_type ))
                {
                    PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'internal_type'" );
                    goto error_exit;
                }

                _python_par_internal_type = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "field_cast_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "field_cast_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "field_cast_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "field_cast_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "field_cast_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "field_cast_sql() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "field_cast_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "field_cast_sql() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "field_cast_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "field_cast_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "field_cast_sql() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "field_cast_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "field_cast_sql() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_db_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'db_type'" );
             goto error_exit;
         }

        _python_par_db_type = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_internal_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "field_cast_sql() got multiple values for keyword argument 'internal_type'" );
             goto error_exit;
         }

        _python_par_internal_type = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_db_type, _python_par_internal_type );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_db_type );
    Py_XDECREF( _python_par_internal_type );

    return NULL;
}

static PyObject *dparse_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return PyList_New( 0 );
}
static PyObject *fparse_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "force_no_ordering() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "force_no_ordering() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "force_no_ordering() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "force_no_ordering() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "force_no_ordering() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "force_no_ordering() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "force_no_ordering() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "force_no_ordering() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "force_no_ordering() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "force_no_ordering() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "force_no_ordering() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "force_no_ordering() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "force_no_ordering() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "force_no_ordering() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "force_no_ordering() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "force_no_ordering() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "force_no_ordering() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_nowait )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_nowait( _python_str_plain_nowait, _python_par_nowait );

    // Actual function code.
    static PyFrameObject *frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_7d7157576e138895029be58f9c1f6fea, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 790 );
        if ( CHECK_IF_TRUE( _python_var_nowait.asObject() ) )
        {
            return INCREASE_REFCOUNT( _python_str_digest_79b4589a10650737a6bd08c62b913b27 );
        }
        else
        {
            return INCREASE_REFCOUNT( _python_str_digest_af1282c73dc107f29cf3673c75d89065 );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_nowait.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_nowait = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "for_update_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "for_update_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_nowait == key )
            {
                if (unlikely( _python_par_nowait ))
                {
                    PyErr_Format( PyExc_TypeError, "for_update_sql() got multiple values for keyword argument 'nowait'" );
                    goto error_exit;
                }

                _python_par_nowait = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "for_update_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_nowait, key ) )
            {
                if (unlikely( _python_par_nowait ))
                {
                    PyErr_Format( PyExc_TypeError, "for_update_sql() got multiple values for keyword argument 'nowait'" );
                    goto error_exit;
                }

                _python_par_nowait = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "for_update_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "for_update_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "for_update_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "for_update_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "for_update_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "for_update_sql() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "for_update_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "for_update_sql() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "for_update_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "for_update_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "for_update_sql() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "for_update_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "for_update_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "for_update_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_nowait != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "for_update_sql() got multiple values for keyword argument 'nowait'" );
             goto error_exit;
         }

        _python_par_nowait = INCREASE_REFCOUNT( args[ 1 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_nowait == NULL )
    {
        _python_par_nowait = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_nowait );
    }


    return impl_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_nowait );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_nowait );

    return NULL;
}

static PyObject *dparse_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_field_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_field_name( _python_str_plain_field_name, _python_par_field_name );

    // Actual function code.
    static PyFrameObject *frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_c80db662812006058d356668a727f708, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 801 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TUPLE1( _python_str_digest_eb21c7431e0778b7cbf83e22caaec4ad ) ).asObject() ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_field_name.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_field_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "fulltext_search_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "fulltext_search_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_field_name == key )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "fulltext_search_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "fulltext_search_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_field_name, key ) )
            {
                if (unlikely( _python_par_field_name ))
                {
                    PyErr_Format( PyExc_TypeError, "fulltext_search_sql() got multiple values for keyword argument 'field_name'" );
                    goto error_exit;
                }

                _python_par_field_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "fulltext_search_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "fulltext_search_sql() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "fulltext_search_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_field_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "fulltext_search_sql() got multiple values for keyword argument 'field_name'" );
             goto error_exit;
         }

        _python_par_field_name = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_field_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_field_name );

    return NULL;
}

static PyObject *dparse_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor, PyObject *_python_par_sql, PyObject *_python_par_params )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );
    PyObjectLocalParameterVariableNoDel _python_var_sql( _python_str_plain_sql, _python_par_sql );
    PyObjectLocalParameterVariableNoDel _python_var_params( _python_str_plain_params, _python_par_params );
    PyObjectSharedLocalVariable _python_var_force_text( _python_str_plain_force_text );
    PyObjectSharedLocalVariable _python_var_to_unicode( _python_str_plain_to_unicode );
    PyObjectLocalVariable _python_var_u_params( _python_str_plain_u_params );

    // Actual function code.
    static PyFrameObject *frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_cdbcca214430403cb9d500ba4c73a5d7, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 813 );
        _python_var_force_text.assign1( IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_5c6adb5fc6275b5d2a085f73ed00809a, ((PyModuleObject *)_module_django__db__backends)->md_dict, PyObjectTemporary( _python_var_params.updateLocalsDict( _python_var_sql.updateLocalsDict( _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_u_params.updateLocalsDict( _python_var_to_unicode.updateLocalsDict( _python_var_force_text.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ).asObject(), _python_list_str_plain_force_text_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_force_text ) );
        _python_var_to_unicode.assign1( MAKE_FUNCTION_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( _python_var_force_text ) );
        frame_guard.setLineNumber( 817 );
        if ( BUILTIN_ISINSTANCE_BOOL( _python_var_params.asObject(), PyObjectTemporary( MAKE_TUPLE2( LOOKUP_BUILTIN( _python_str_plain_list ), LOOKUP_BUILTIN( _python_str_plain_tuple ) ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 818 );
            _python_var_u_params.assign1( TO_TUPLE( PyObjectTemporary( impl_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( MAKE_ITERATOR( _python_var_params.asObject() ), _python_var_to_unicode ) ).asObject() ) );
        }
        else
        {
            frame_guard.setLineNumber( 819 );
            if ( ( _python_var_params.asObject() == Py_None ) )
            {
                _python_var_u_params.assign0( _python_tuple_empty );
            }
            else
            {
                frame_guard.setLineNumber( 822 );
                _python_var_u_params.assign1( TO_DICT( PyObjectTemporary( impl_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( MAKE_ITERATOR( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_params.asObject(), _python_str_plain_items ) ).asObject() ) ).asObject() ), _python_var_to_unicode ) ).asObject(), NULL ) );
            }
        }
        frame_guard.setLineNumber( 824 );
        {
            PyObjectTempKeeper0 make_tuple1;
            PyObjectTempKeeper1 op3;
            return ( op3.assign( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_six.asObject0(), _python_str_plain_text_type ) ).asObject(), _python_str_digest_a4f275664462e3d3da210b2d757ede71 ) ), BINARY_OPERATION_REMAINDER( op3.asObject0(), PyObjectTemporary( ( make_tuple1.assign( _python_var_sql.asObject() ), MAKE_TUPLE2( make_tuple1.asObject0(), _python_var_u_params.asObject() ) ) ).asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_params.updateLocalsDict( _python_var_sql.updateLocalsDict( _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_u_params.updateLocalsDict( _python_var_to_unicode.updateLocalsDict( _python_var_force_text.updateLocalsDict( PyDict_New() ) ) ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    PyObject *_python_par_sql = NULL;
    PyObject *_python_par_params = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "last_executed_query() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sql == key )
            {
                if (unlikely( _python_par_sql ))
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'sql'" );
                    goto error_exit;
                }

                _python_par_sql = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_params == key )
            {
                if (unlikely( _python_par_params ))
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'params'" );
                    goto error_exit;
                }

                _python_par_params = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sql, key ) )
            {
                if (unlikely( _python_par_sql ))
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'sql'" );
                    goto error_exit;
                }

                _python_par_sql = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_params, key ) )
            {
                if (unlikely( _python_par_params ))
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'params'" );
                    goto error_exit;
                }

                _python_par_params = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "last_executed_query() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 4 ))
    {
        if ( 4 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "last_executed_query() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "last_executed_query() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "last_executed_query() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "last_executed_query() takes exactly %d arguments (%zd given)", 4, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "last_executed_query() takes exactly %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "last_executed_query() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#else
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "last_executed_query() takes %d positional arguments but %zd were given", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "last_executed_query() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 4 ))
    {
        if ( 4 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "last_executed_query() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "last_executed_query() takes exactly %d non-keyword arguments (%zd given)", 4, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 4 == 4 )
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() takes exactly %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "last_executed_query() takes at least %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 4 ? args_given : 4;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_sql != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'sql'" );
             goto error_exit;
         }

        _python_par_sql = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_params != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "last_executed_query() got multiple values for keyword argument 'params'" );
             goto error_exit;
         }

        _python_par_params = INCREASE_REFCOUNT( args[ 3 ] );
    }


    return impl_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_cursor, _python_par_sql, _python_par_params );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );
    Py_XDECREF( _python_par_sql );
    Py_XDECREF( _python_par_params );

    return NULL;
}

static PyObject *dparse_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 4)
    {
        return impl_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_s )
{
    // The context of the function.
    struct _context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = (struct _context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *)self->m_context;

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_s( _python_str_plain_s, _python_par_s );

    // Actual function code.
    static PyFrameObject *frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_e7f0ad9b8d147e593177147d187993d4, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 816 );
        {
            PyObjectTempKeeper0 call1;
            return ( call1.assign( _python_context->python_closure_force_text.asObject() ), CALL_FUNCTION( call1.asObject0(), PyObjectTemporary( MAKE_TUPLE1( _python_var_s.asObject() ) ).asObject(), PyObjectTemporary( PyDict_Copy( _python_dict_38f040bfe209e4a020e91ff7d4103928 ) ).asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_s.updateLocalsDict( _python_context->python_closure_force_text.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_s = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "<lambda>() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_s == key )
            {
                if (unlikely( _python_par_s ))
                {
                    PyErr_Format( PyExc_TypeError, "<lambda>() got multiple values for keyword argument 's'" );
                    goto error_exit;
                }

                _python_par_s = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_s, key ) )
            {
                if (unlikely( _python_par_s ))
                {
                    PyErr_Format( PyExc_TypeError, "<lambda>() got multiple values for keyword argument 's'" );
                    goto error_exit;
                }

                _python_par_s = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "<lambda>() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "<lambda>() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "<lambda>() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "<lambda>() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "<lambda>() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "<lambda>() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "<lambda>() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "<lambda>() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "<lambda>() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "<lambda>() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "<lambda>() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "<lambda>() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "<lambda>() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_s != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "<lambda>() got multiple values for keyword argument 's'" );
             goto error_exit;
         }

        _python_par_s = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_s );

error_exit:;

    Py_XDECREF( _python_par_s );

    return NULL;
}

static PyObject *dparse_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}




struct _context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t
{
    // The generator function instance can access its parameters from creation time.
    PyObjectClosureVariable python_closure_to_unicode;
    PyObjectLocalParameterVariableNoDel python_var___iterator;
    PyObjectLocalVariable python_var_val;
};

static void _context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_destructor( void *context_voidptr )
{
    _context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = (struct _context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *)context_voidptr;

    delete _python_context;
}

static void genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_context( Nuitka_GeneratorObject *generator )
{
    {
        // Make context accessible if one is used.

        NUITKA_MAY_BE_UNUSED struct _context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = (_context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *)generator->m_context;


        // Local variable inits
        _python_context->python_var_val.setVariableName( _python_str_plain_val );

        // Actual function code.
        static PyFrameObject *frame_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

        // Must be inside block, or else its d-tor will not be run.
        if ( isFrameUnusable( frame_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
        {
            if ( frame_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
            {
#if _DEBUG_REFRAME
                puts( "reframe for genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
                Py_DECREF( frame_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
            }

            frame_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_c5bc605b2611a5079be9beca9939a533, _module_django__db__backends );
        }

        Py_INCREF( frame_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        generator->m_frame = frame_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends;

        Py_CLEAR( generator->m_frame->f_back );

        generator->m_frame->f_back = PyThreadState_GET()->frame;
        Py_INCREF( generator->m_frame->f_back );

        PyThreadState_GET()->frame = generator->m_frame;

        FrameGuardLight frame_guard( &generator->m_frame );

        // TODO: The inject of the exception through C++ is very non-optimal, this flag
        // now indicates only if the exception occurs initially as supposed, or during
        // life, this could and should be shortcut.
        bool traceback;

        try
        {
            // TODO: In case we don't raise exceptions ourselves, we would still have to do this, so
            // beware to not optimize this away for generators without a replacement.
            traceback = true;
            CHECK_EXCEPTION( generator );
            traceback = false;

            {
                {
                    frame_guard.setLineNumber( 818 );
                    PyObject *_python_tmp_contraction_iter = _python_context->python_var___iterator.asObject();
                    while( true )
                    {
                        frame_guard.setLineNumber( 818 );
                        PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_contraction_iter );

                        if ( _tmp_unpack_1 == NULL )
                        {
                            break;
                        }
                        PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                        _python_context->python_var_val.assign0( _python_tmp_iter_value.asObject() );
                        {
                            PyObjectTempKeeper0 call1;
                            YIELD_VALUE( generator, ( call1.assign( _python_context->python_closure_to_unicode.asObject() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_context->python_var_val.asObject() ) ) );
                        }

                       CONSIDER_THREADING();
                    }
                }
            }

            PyErr_SetNone( PyExc_StopIteration );
        }
        catch ( PythonException &_exception )
        {
            if ( !_exception.hasTraceback() )
            {
                _exception.setTraceback( MAKE_TRACEBACK( INCREASE_REFCOUNT( generator->m_frame ) ) );
            }
            else if ( traceback == false )
            {
                _exception.addTraceback( generator->m_frame );
            }
            _exception.toPython();

            // TODO: Moving this code is not allowed yet.
            generator->m_yielded = NULL;
        }
    }

    // TODO: Won't return, we should tell the compiler about that.
    generator->m_yielded = NULL;
    swapFiber( &generator->m_yielder_context, &generator->m_caller_context );
}

static PyObject *impl_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( PyObject *_python_par___iterator, PyObjectSharedLocalVariable &python_closure_to_unicode )
{
    // Create context if any
    struct _context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = new _context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t;
    _python_context->python_closure_to_unicode.shareWith( python_closure_to_unicode );

    try
    {
        PyObject *result = Nuitka_Generator_New(
            genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_context,
            _python_str_angle_genexpr,
            _codeobj_e7b66f85f318d2ceba4e74a18bab7a3f,
            _python_context,
            _context_generator_genexpr_2_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_destructor
        );

        if (unlikely( result == NULL ))
        {
            PyErr_Format( PyExc_RuntimeError, "cannot create function <genexpr>" );
            return NULL;
        }

        // Copy to context parameter values and closured variables if any.
        _python_context->python_var___iterator.setVariableNameAndValue( _python_str_plain___iterator, _python_par___iterator );

        return result;
    }
    catch ( PythonException &_exception )
    {
        _exception.toPython();

        return NULL;
    }
}



struct _context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t
{
    // The generator function instance can access its parameters from creation time.
    PyObjectClosureVariable python_closure_to_unicode;
    PyObjectLocalParameterVariableNoDel python_var___iterator;
    PyObjectLocalVariable python_var_k;
    PyObjectLocalVariable python_var_v;
};

static void _context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_destructor( void *context_voidptr )
{
    _context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = (struct _context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *)context_voidptr;

    delete _python_context;
}

static void genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_context( Nuitka_GeneratorObject *generator )
{
    {
        // Make context accessible if one is used.

        NUITKA_MAY_BE_UNUSED struct _context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = (_context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *)generator->m_context;


        // Local variable inits
        _python_context->python_var_k.setVariableName( _python_str_plain_k );
        _python_context->python_var_v.setVariableName( _python_str_plain_v );

        // Actual function code.
        static PyFrameObject *frame_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

        // Must be inside block, or else its d-tor will not be run.
        if ( isFrameUnusable( frame_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
        {
            if ( frame_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
            {
#if _DEBUG_REFRAME
                puts( "reframe for genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
                Py_DECREF( frame_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
            }

            frame_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_d81b61b93287f2d3776ecd10daefb382, _module_django__db__backends );
        }

        Py_INCREF( frame_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        generator->m_frame = frame_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends;

        Py_CLEAR( generator->m_frame->f_back );

        generator->m_frame->f_back = PyThreadState_GET()->frame;
        Py_INCREF( generator->m_frame->f_back );

        PyThreadState_GET()->frame = generator->m_frame;

        FrameGuardLight frame_guard( &generator->m_frame );

        // TODO: The inject of the exception through C++ is very non-optimal, this flag
        // now indicates only if the exception occurs initially as supposed, or during
        // life, this could and should be shortcut.
        bool traceback;

        try
        {
            // TODO: In case we don't raise exceptions ourselves, we would still have to do this, so
            // beware to not optimize this away for generators without a replacement.
            traceback = true;
            CHECK_EXCEPTION( generator );
            traceback = false;

            {
                {
                    frame_guard.setLineNumber( 822 );
                    PyObject *_python_tmp_contraction_iter = _python_context->python_var___iterator.asObject();
                    while( true )
                    {
                        frame_guard.setLineNumber( 822 );
                        PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_contraction_iter );

                        if ( _tmp_unpack_1 == NULL )
                        {
                            break;
                        }
                        PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                        {
                            frame_guard.setLineNumber( 822 );
                            PyObjectTemporary _python_tmp_source_iter( MAKE_ITERATOR( _python_tmp_iter_value.asObject() ) );
                            PyObjectTemporary _python_tmp_element_1( UNPACK_NEXT( _python_tmp_source_iter.asObject(), 0 ) );
                            PyObjectTemporary _python_tmp_element_2( UNPACK_NEXT( _python_tmp_source_iter.asObject(), 1 ) );
                            UNPACK_ITERATOR_CHECK( _python_tmp_source_iter.asObject(), 2 );
                            _python_context->python_var_k.assign0( _python_tmp_element_1.asObject() );
                            _python_context->python_var_v.assign0( _python_tmp_element_2.asObject() );
                        }
                        {
                            PyObjectTempKeeper0 call1;
                            PyObjectTempKeeper0 call3;
                            PyObjectTempKeeper1 make_tuple5;
                            YIELD_VALUE( generator, ( make_tuple5.assign( ( call1.assign( _python_context->python_closure_to_unicode.asObject() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_context->python_var_k.asObject() ) ) ), MAKE_TUPLE2( make_tuple5.asObject0(), PyObjectTemporary( ( call3.assign( _python_context->python_closure_to_unicode.asObject() ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), _python_context->python_var_v.asObject() ) ) ).asObject() ) ) );
                        }

                       CONSIDER_THREADING();
                    }
                }
            }

            PyErr_SetNone( PyExc_StopIteration );
        }
        catch ( PythonException &_exception )
        {
            if ( !_exception.hasTraceback() )
            {
                _exception.setTraceback( MAKE_TRACEBACK( INCREASE_REFCOUNT( generator->m_frame ) ) );
            }
            else if ( traceback == false )
            {
                _exception.addTraceback( generator->m_frame );
            }
            _exception.toPython();

            // TODO: Moving this code is not allowed yet.
            generator->m_yielded = NULL;
        }
    }

    // TODO: Won't return, we should tell the compiler about that.
    generator->m_yielded = NULL;
    swapFiber( &generator->m_yielder_context, &generator->m_caller_context );
}

static PyObject *impl_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( PyObject *_python_par___iterator, PyObjectSharedLocalVariable &python_closure_to_unicode )
{
    // Create context if any
    struct _context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = new _context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t;
    _python_context->python_closure_to_unicode.shareWith( python_closure_to_unicode );

    try
    {
        PyObject *result = Nuitka_Generator_New(
            genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_context,
            _python_str_angle_genexpr,
            _codeobj_b3327687eb1ed96e2dc5938c4d29a931,
            _python_context,
            _context_generator_genexpr_3_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_destructor
        );

        if (unlikely( result == NULL ))
        {
            PyErr_Format( PyExc_RuntimeError, "cannot create function <genexpr>" );
            return NULL;
        }

        // Copy to context parameter values and closured variables if any.
        _python_context->python_var___iterator.setVariableNameAndValue( _python_str_plain___iterator, _python_par___iterator );

        return result;
    }
    catch ( PythonException &_exception )
    {
        _exception.toPython();

        return NULL;
    }
}


static PyObject *impl_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor, PyObject *_python_par_table_name, PyObject *_python_par_pk_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );
    PyObjectLocalParameterVariableNoDel _python_var_table_name( _python_str_plain_table_name, _python_par_table_name );
    PyObjectLocalParameterVariableNoDel _python_var_pk_name( _python_str_plain_pk_name, _python_par_pk_name );

    // Actual function code.
    static PyFrameObject *frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_b45cf12a4d3734a644bcb40e2fe9df27, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 834 );
        return LOOKUP_ATTRIBUTE( _python_var_cursor.asObject(), _python_str_plain_lastrowid );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_pk_name.updateLocalsDict( _python_var_table_name.updateLocalsDict( _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    PyObject *_python_par_table_name = NULL;
    PyObject *_python_par_pk_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "last_insert_id() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_table_name == key )
            {
                if (unlikely( _python_par_table_name ))
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'table_name'" );
                    goto error_exit;
                }

                _python_par_table_name = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_pk_name == key )
            {
                if (unlikely( _python_par_pk_name ))
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'pk_name'" );
                    goto error_exit;
                }

                _python_par_pk_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_table_name, key ) )
            {
                if (unlikely( _python_par_table_name ))
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'table_name'" );
                    goto error_exit;
                }

                _python_par_table_name = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_pk_name, key ) )
            {
                if (unlikely( _python_par_pk_name ))
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'pk_name'" );
                    goto error_exit;
                }

                _python_par_pk_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "last_insert_id() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 4 ))
    {
        if ( 4 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "last_insert_id() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "last_insert_id() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "last_insert_id() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "last_insert_id() takes exactly %d arguments (%zd given)", 4, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "last_insert_id() takes exactly %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "last_insert_id() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#else
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "last_insert_id() takes %d positional arguments but %zd were given", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "last_insert_id() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 4 ))
    {
        if ( 4 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "last_insert_id() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "last_insert_id() takes exactly %d non-keyword arguments (%zd given)", 4, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 4 == 4 )
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() takes exactly %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "last_insert_id() takes at least %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 4 ? args_given : 4;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_table_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'table_name'" );
             goto error_exit;
         }

        _python_par_table_name = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_pk_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "last_insert_id() got multiple values for keyword argument 'pk_name'" );
             goto error_exit;
         }

        _python_par_pk_name = INCREASE_REFCOUNT( args[ 3 ] );
    }


    return impl_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_cursor, _python_par_table_name, _python_par_pk_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );
    Py_XDECREF( _python_par_table_name );
    Py_XDECREF( _python_par_pk_name );

    return NULL;
}

static PyObject *dparse_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 4)
    {
        return impl_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_lookup_type )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_lookup_type( _python_str_plain_lookup_type, _python_par_lookup_type );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_digest_1c481aa99d081c32182011a758f73d33 );
}
static PyObject *fparse_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_lookup_type = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "lookup_cast() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "lookup_cast() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_lookup_type == key )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "lookup_cast() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "lookup_cast() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_lookup_type, key ) )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "lookup_cast() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "lookup_cast() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "lookup_cast() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "lookup_cast() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "lookup_cast() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "lookup_cast() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "lookup_cast() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "lookup_cast() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "lookup_cast() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "lookup_cast() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "lookup_cast() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "lookup_cast() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "lookup_cast() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "lookup_cast() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "lookup_cast() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_lookup_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "lookup_cast() got multiple values for keyword argument 'lookup_type'" );
             goto error_exit;
         }

        _python_par_lookup_type = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_lookup_type );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_lookup_type );

    return NULL;
}

static PyObject *dparse_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "max_in_list_size() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "max_in_list_size() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "max_in_list_size() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "max_in_list_size() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "max_in_list_size() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "max_in_list_size() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "max_in_list_size() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "max_in_list_size() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "max_in_list_size() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "max_in_list_size() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "max_in_list_size() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "max_in_list_size() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "max_in_list_size() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "max_in_list_size() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "max_in_list_size() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "max_in_list_size() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "max_in_list_size() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "max_name_length() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "max_name_length() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "max_name_length() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "max_name_length() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "max_name_length() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "max_name_length() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "max_name_length() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "max_name_length() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "max_name_length() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "max_name_length() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "max_name_length() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "max_name_length() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "max_name_length() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "max_name_length() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "max_name_length() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "max_name_length() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "max_name_length() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_95148283ed1d9f6430dbc75efd943da4, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 863 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "no_limit_value() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "no_limit_value() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "no_limit_value() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "no_limit_value() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "no_limit_value() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "no_limit_value() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "no_limit_value() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "no_limit_value() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "no_limit_value() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "no_limit_value() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "no_limit_value() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "no_limit_value() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "no_limit_value() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "no_limit_value() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "no_limit_value() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "no_limit_value() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "no_limit_value() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_plain_DEFAULT );
}
static PyObject *fparse_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "pk_default_value() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "pk_default_value() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "pk_default_value() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "pk_default_value() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "pk_default_value() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "pk_default_value() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "pk_default_value() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "pk_default_value() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "pk_default_value() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "pk_default_value() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "pk_default_value() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "pk_default_value() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "pk_default_value() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "pk_default_value() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "pk_default_value() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "pk_default_value() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "pk_default_value() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );

    // Actual function code.
    static PyFrameObject *frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_c3d627ca9aa8af38487dfe64f8f3264d, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 877 );
        return _python_var_value.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "process_clob() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "process_clob() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "process_clob() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "process_clob() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "process_clob() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "process_clob() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "process_clob() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "process_clob() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "process_clob() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "process_clob() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "process_clob() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "process_clob() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "process_clob() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "process_clob() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "process_clob() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "process_clob() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "process_clob() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "process_clob() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "process_clob() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "process_clob() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );

    return NULL;
}

static PyObject *dparse_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "return_insert_id() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "return_insert_id() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "return_insert_id() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "return_insert_id() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "return_insert_id() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "return_insert_id() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "return_insert_id() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "return_insert_id() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "return_insert_id() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "return_insert_id() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "return_insert_id() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "return_insert_id() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "return_insert_id() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "return_insert_id() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "return_insert_id() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "return_insert_id() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "return_insert_id() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_compiler_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_compiler_name( _python_str_plain_compiler_name, _python_par_compiler_name );

    // Actual function code.
    static PyFrameObject *frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_dfb000688c0f14972c0ebe8762dc8710, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 894 );
        if ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__cache ) ).asObject() == Py_None ) )
        {
            frame_guard.setLineNumber( 895 );
            {
                PyObjectTempKeeper0 call1;
                {
                    PyObjectTemporary tmp_identifier( ( call1.assign( _mvar_django__db__backends_import_module.asObject0() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_compiler_module ) ).asObject() ) ) );
                    SET_ATTRIBUTE( tmp_identifier.asObject(), _python_var_self.asObject(), _python_str_plain__cache );
            }
            }
        }
        frame_guard.setLineNumber( 896 );
        {
            PyObjectTempKeeper1 getattr3;
            return ( getattr3.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain__cache ) ), BUILTIN_GETATTR( getattr3.asObject0(), _python_var_compiler_name.asObject(), NULL ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_compiler_name.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_compiler_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "compiler() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "compiler() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_compiler_name == key )
            {
                if (unlikely( _python_par_compiler_name ))
                {
                    PyErr_Format( PyExc_TypeError, "compiler() got multiple values for keyword argument 'compiler_name'" );
                    goto error_exit;
                }

                _python_par_compiler_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "compiler() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_compiler_name, key ) )
            {
                if (unlikely( _python_par_compiler_name ))
                {
                    PyErr_Format( PyExc_TypeError, "compiler() got multiple values for keyword argument 'compiler_name'" );
                    goto error_exit;
                }

                _python_par_compiler_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "compiler() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "compiler() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "compiler() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "compiler() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "compiler() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "compiler() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "compiler() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "compiler() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "compiler() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "compiler() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "compiler() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "compiler() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "compiler() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "compiler() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_compiler_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "compiler() got multiple values for keyword argument 'compiler_name'" );
             goto error_exit;
         }

        _python_par_compiler_name = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_compiler_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_compiler_name );

    return NULL;
}

static PyObject *dparse_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_name( _python_str_plain_name, _python_par_name );

    // Actual function code.
    static PyFrameObject *frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_7b8c0f99645a001cab8018fee70ca93a, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 903 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, _python_tuple_empty ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_name.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "quote_name() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "quote_name() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_name == key )
            {
                if (unlikely( _python_par_name ))
                {
                    PyErr_Format( PyExc_TypeError, "quote_name() got multiple values for keyword argument 'name'" );
                    goto error_exit;
                }

                _python_par_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "quote_name() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_name, key ) )
            {
                if (unlikely( _python_par_name ))
                {
                    PyErr_Format( PyExc_TypeError, "quote_name() got multiple values for keyword argument 'name'" );
                    goto error_exit;
                }

                _python_par_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "quote_name() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "quote_name() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "quote_name() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "quote_name() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "quote_name() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "quote_name() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "quote_name() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "quote_name() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "quote_name() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "quote_name() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "quote_name() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "quote_name() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "quote_name() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "quote_name() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "quote_name() got multiple values for keyword argument 'name'" );
             goto error_exit;
         }

        _python_par_name = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_name );

    return NULL;
}

static PyObject *dparse_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_digest_2e410d73afa48e0e5408fecde96538f6 );
}
static PyObject *fparse_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "random_function_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "random_function_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "random_function_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "random_function_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "random_function_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "random_function_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "random_function_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "random_function_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "random_function_sql() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "random_function_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "random_function_sql() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "random_function_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "random_function_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "random_function_sql() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "random_function_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "random_function_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "random_function_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_lookup_type )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_lookup_type( _python_str_plain_lookup_type, _python_par_lookup_type );

    // Actual function code.
    static PyFrameObject *frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_9fbdf013283ffb39f5464e3b36b8e695, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 920 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_lookup_type.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_lookup_type = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "regex_lookup() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "regex_lookup() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_lookup_type == key )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "regex_lookup() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "regex_lookup() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_lookup_type, key ) )
            {
                if (unlikely( _python_par_lookup_type ))
                {
                    PyErr_Format( PyExc_TypeError, "regex_lookup() got multiple values for keyword argument 'lookup_type'" );
                    goto error_exit;
                }

                _python_par_lookup_type = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "regex_lookup() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "regex_lookup() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "regex_lookup() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "regex_lookup() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "regex_lookup() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "regex_lookup() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "regex_lookup() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "regex_lookup() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "regex_lookup() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "regex_lookup() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "regex_lookup() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "regex_lookup() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "regex_lookup() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "regex_lookup() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_lookup_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "regex_lookup() got multiple values for keyword argument 'lookup_type'" );
             goto error_exit;
         }

        _python_par_lookup_type = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_lookup_type );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_lookup_type );

    return NULL;
}

static PyObject *dparse_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sid )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sid( _python_str_plain_sid, _python_par_sid );

    // Actual function code.
    static PyFrameObject *frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_4b8bb88f4c652de38f1188014360aa1e, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 928 );
        {
            PyObjectTempKeeper1 call1;
            return BINARY_OPERATION_REMAINDER( _python_str_digest_3f955cbde39e04b9fe791e94cc21a510, PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_quote_name ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sid.asObject() ) ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sid.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sid = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "savepoint_create_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_create_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sid == key )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_create_sql() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_create_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sid, key ) )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_create_sql() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "savepoint_create_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_create_sql() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_create_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sid != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_create_sql() got multiple values for keyword argument 'sid'" );
             goto error_exit;
         }

        _python_par_sid = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_sid );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sid );

    return NULL;
}

static PyObject *dparse_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sid )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sid( _python_str_plain_sid, _python_par_sid );

    // Actual function code.
    static PyFrameObject *frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_90b90a54eb6c8f017d4d704fba8f94bc, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 934 );
        {
            PyObjectTempKeeper1 call1;
            return BINARY_OPERATION_REMAINDER( _python_str_digest_0145aca140ed6489d8949b3ef6e1a409, PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_quote_name ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sid.asObject() ) ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sid.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sid = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sid == key )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sid, key ) )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "savepoint_commit_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sid != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_commit_sql() got multiple values for keyword argument 'sid'" );
             goto error_exit;
         }

        _python_par_sid = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_sid );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sid );

    return NULL;
}

static PyObject *dparse_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_sid )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_sid( _python_str_plain_sid, _python_par_sid );

    // Actual function code.
    static PyFrameObject *frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_da364956461cf6368aed8818de0359a0, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 940 );
        {
            PyObjectTempKeeper1 call1;
            return BINARY_OPERATION_REMAINDER( _python_str_digest_2251acd4497775d7e855670cd3ff0037, PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_quote_name ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sid.asObject() ) ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sid.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_sid = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sid == key )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sid, key ) )
            {
                if (unlikely( _python_par_sid ))
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() got multiple values for keyword argument 'sid'" );
                    goto error_exit;
                }

                _python_par_sid = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "savepoint_rollback_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_sid != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "savepoint_rollback_sql() got multiple values for keyword argument 'sid'" );
             goto error_exit;
         }

        _python_par_sid = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_sid );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_sid );

    return NULL;
}

static PyObject *dparse_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_empty );
}
static PyObject *fparse_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "set_time_zone_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "set_time_zone_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "set_time_zone_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "set_time_zone_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "set_time_zone_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "set_time_zone_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_style, PyObject *_python_par_tables, PyObject *_python_par_sequences, PyObject *_python_par_allow_cascade )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_style( _python_str_plain_style, _python_par_style );
    PyObjectLocalParameterVariableNoDel _python_var_tables( _python_str_plain_tables, _python_par_tables );
    PyObjectLocalParameterVariableNoDel _python_var_sequences( _python_str_plain_sequences, _python_par_sequences );
    PyObjectLocalParameterVariableNoDel _python_var_allow_cascade( _python_str_plain_allow_cascade, _python_par_allow_cascade );

    // Actual function code.
    static PyFrameObject *frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_18acb977c380db3ac80c79e6488b6050, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 966 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, _python_tuple_empty ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_allow_cascade.updateLocalsDict( _python_var_sequences.updateLocalsDict( _python_var_tables.updateLocalsDict( _python_var_style.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_style = NULL;
    PyObject *_python_par_tables = NULL;
    PyObject *_python_par_sequences = NULL;
    PyObject *_python_par_allow_cascade = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "sql_flush() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_style == key )
            {
                if (unlikely( _python_par_style ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'style'" );
                    goto error_exit;
                }

                _python_par_style = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_tables == key )
            {
                if (unlikely( _python_par_tables ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'tables'" );
                    goto error_exit;
                }

                _python_par_tables = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sequences == key )
            {
                if (unlikely( _python_par_sequences ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'sequences'" );
                    goto error_exit;
                }

                _python_par_sequences = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_allow_cascade == key )
            {
                if (unlikely( _python_par_allow_cascade ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'allow_cascade'" );
                    goto error_exit;
                }

                _python_par_allow_cascade = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_style, key ) )
            {
                if (unlikely( _python_par_style ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'style'" );
                    goto error_exit;
                }

                _python_par_style = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_tables, key ) )
            {
                if (unlikely( _python_par_tables ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'tables'" );
                    goto error_exit;
                }

                _python_par_tables = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sequences, key ) )
            {
                if (unlikely( _python_par_sequences ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'sequences'" );
                    goto error_exit;
                }

                _python_par_sequences = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_allow_cascade, key ) )
            {
                if (unlikely( _python_par_allow_cascade ))
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'allow_cascade'" );
                    goto error_exit;
                }

                _python_par_allow_cascade = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "sql_flush() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 5 ))
    {
        if ( 5 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "sql_flush() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "sql_flush() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "sql_flush() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "sql_flush() takes exactly %d arguments (%zd given)", 5, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 5 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "sql_flush() takes exactly %d positional arguments (%zd given)", 5, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "sql_flush() takes at most %d positional arguments (%zd given)", 5, args_given + kw_only_found );
            }
#else
            if ( 5 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "sql_flush() takes %d positional arguments but %zd were given", 5, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "sql_flush() takes at most %d positional arguments (%zd given)", 5, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 4 ))
    {
        if ( 5 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "sql_flush() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "sql_flush() takes exactly %d non-keyword arguments (%zd given)", 5, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 5 == 4 )
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() takes exactly %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "sql_flush() takes at least %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 5 ? args_given : 5;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_style != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'style'" );
             goto error_exit;
         }

        _python_par_style = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_tables != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'tables'" );
             goto error_exit;
         }

        _python_par_tables = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_sequences != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'sequences'" );
             goto error_exit;
         }

        _python_par_sequences = INCREASE_REFCOUNT( args[ 3 ] );
    }
    if (likely( 4 < args_usable_count ))
    {
         if (unlikely( _python_par_allow_cascade != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sql_flush() got multiple values for keyword argument 'allow_cascade'" );
             goto error_exit;
         }

        _python_par_allow_cascade = INCREASE_REFCOUNT( args[ 4 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_allow_cascade == NULL )
    {
        _python_par_allow_cascade = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_allow_cascade );
    }


    return impl_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_style, _python_par_tables, _python_par_sequences, _python_par_allow_cascade );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_style );
    Py_XDECREF( _python_par_tables );
    Py_XDECREF( _python_par_sequences );
    Py_XDECREF( _python_par_allow_cascade );

    return NULL;
}

static PyObject *dparse_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 5)
    {
        return impl_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ), INCREASE_REFCOUNT( args[ 4 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_style, PyObject *_python_par_sequences )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_style( _python_str_plain_style, _python_par_style );
    PyObjectLocalParameterVariableNoDel _python_var_sequences( _python_str_plain_sequences, _python_par_sequences );

    // Actual function code.
    return PyList_New( 0 );
}
static PyObject *fparse_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_style = NULL;
    PyObject *_python_par_sequences = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_style == key )
            {
                if (unlikely( _python_par_style ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'style'" );
                    goto error_exit;
                }

                _python_par_style = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sequences == key )
            {
                if (unlikely( _python_par_sequences ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'sequences'" );
                    goto error_exit;
                }

                _python_par_sequences = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_style, key ) )
            {
                if (unlikely( _python_par_style ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'style'" );
                    goto error_exit;
                }

                _python_par_style = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sequences, key ) )
            {
                if (unlikely( _python_par_sequences ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'sequences'" );
                    goto error_exit;
                }

                _python_par_sequences = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "sequence_reset_by_name_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_style != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'style'" );
             goto error_exit;
         }

        _python_par_style = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_sequences != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sequence_reset_by_name_sql() got multiple values for keyword argument 'sequences'" );
             goto error_exit;
         }

        _python_par_sequences = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_style, _python_par_sequences );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_style );
    Py_XDECREF( _python_par_sequences );

    return NULL;
}

static PyObject *dparse_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_style, PyObject *_python_par_model_list )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_style( _python_str_plain_style, _python_par_style );
    PyObjectLocalParameterVariableNoDel _python_var_model_list( _python_str_plain_model_list, _python_par_model_list );

    // Actual function code.
    return PyList_New( 0 );
}
static PyObject *fparse_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_style = NULL;
    PyObject *_python_par_model_list = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_style == key )
            {
                if (unlikely( _python_par_style ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'style'" );
                    goto error_exit;
                }

                _python_par_style = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_model_list == key )
            {
                if (unlikely( _python_par_model_list ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'model_list'" );
                    goto error_exit;
                }

                _python_par_model_list = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_style, key ) )
            {
                if (unlikely( _python_par_style ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'style'" );
                    goto error_exit;
                }

                _python_par_style = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_model_list, key ) )
            {
                if (unlikely( _python_par_model_list ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'model_list'" );
                    goto error_exit;
                }

                _python_par_model_list = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "sequence_reset_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "sequence_reset_sql() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_style != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'style'" );
             goto error_exit;
         }

        _python_par_style = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_model_list != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sequence_reset_sql() got multiple values for keyword argument 'model_list'" );
             goto error_exit;
         }

        _python_par_model_list = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_style, _python_par_model_list );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_style );
    Py_XDECREF( _python_par_model_list );

    return NULL;
}

static PyObject *dparse_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_digest_f2bb30f96be7c06cb8f1917f172a57ce );
}
static PyObject *fparse_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "start_transaction_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "start_transaction_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "start_transaction_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "start_transaction_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "start_transaction_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "start_transaction_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_success )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_success( _python_str_plain_success, _python_par_success );

    // Actual function code.
    static PyFrameObject *frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_e2b49dc185aa7db41f64acc0099223c0, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 998 );
        if ( (!( CHECK_IF_TRUE( _python_var_success.asObject() ) )) )
        {
            return INCREASE_REFCOUNT( _python_str_digest_dc6541776ef671a77e4dfd76dbcfd4cc );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_success.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( _python_str_digest_f55491f57410557264aac04492c0232c );
}
static PyObject *fparse_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_success = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "end_transaction_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "end_transaction_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_success == key )
            {
                if (unlikely( _python_par_success ))
                {
                    PyErr_Format( PyExc_TypeError, "end_transaction_sql() got multiple values for keyword argument 'success'" );
                    goto error_exit;
                }

                _python_par_success = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "end_transaction_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_success, key ) )
            {
                if (unlikely( _python_par_success ))
                {
                    PyErr_Format( PyExc_TypeError, "end_transaction_sql() got multiple values for keyword argument 'success'" );
                    goto error_exit;
                }

                _python_par_success = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "end_transaction_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "end_transaction_sql() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "end_transaction_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_success != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "end_transaction_sql() got multiple values for keyword argument 'success'" );
             goto error_exit;
         }

        _python_par_success = INCREASE_REFCOUNT( args[ 1 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_success == NULL )
    {
        _python_par_success = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_success );
    }


    return impl_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_success );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_success );

    return NULL;
}

static PyObject *dparse_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_tablespace, PyObject *_python_par_inline )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_tablespace( _python_str_plain_tablespace, _python_par_tablespace );
    PyObjectLocalParameterVariableNoDel _python_var_inline( _python_str_plain_inline, _python_par_inline );

    // Actual function code.
    return INCREASE_REFCOUNT( _python_str_empty );
}
static PyObject *fparse_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_tablespace = NULL;
    PyObject *_python_par_inline = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "tablespace_sql() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_tablespace == key )
            {
                if (unlikely( _python_par_tablespace ))
                {
                    PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'tablespace'" );
                    goto error_exit;
                }

                _python_par_tablespace = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_inline == key )
            {
                if (unlikely( _python_par_inline ))
                {
                    PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'inline'" );
                    goto error_exit;
                }

                _python_par_inline = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_tablespace, key ) )
            {
                if (unlikely( _python_par_tablespace ))
                {
                    PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'tablespace'" );
                    goto error_exit;
                }

                _python_par_tablespace = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_inline, key ) )
            {
                if (unlikely( _python_par_inline ))
                {
                    PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'inline'" );
                    goto error_exit;
                }

                _python_par_inline = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "tablespace_sql() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "tablespace_sql() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "tablespace_sql() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "tablespace_sql() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "tablespace_sql() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "tablespace_sql() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "tablespace_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "tablespace_sql() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "tablespace_sql() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "tablespace_sql() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "tablespace_sql() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "tablespace_sql() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "tablespace_sql() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_tablespace != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'tablespace'" );
             goto error_exit;
         }

        _python_par_tablespace = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_inline != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "tablespace_sql() got multiple values for keyword argument 'inline'" );
             goto error_exit;
         }

        _python_par_inline = INCREASE_REFCOUNT( args[ 2 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_inline == NULL )
    {
        _python_par_inline = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_inline );
    }


    return impl_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_tablespace, _python_par_inline );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_tablespace );
    Py_XDECREF( _python_par_inline );

    return NULL;
}

static PyObject *dparse_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_x )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_x( _python_str_plain_x, _python_par_x );
    PyObjectLocalVariable _python_var_force_text( _python_str_plain_force_text );

    // Actual function code.
    static PyFrameObject *frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_1a09a9a082aa896d786097b003e90283, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1015 );
        _python_var_force_text.assign1( IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_5c6adb5fc6275b5d2a085f73ed00809a, ((PyModuleObject *)_module_django__db__backends)->md_dict, PyObjectTemporary( _python_var_x.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_force_text.updateLocalsDict( PyDict_New() ) ) ) ).asObject(), _python_list_str_plain_force_text_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_force_text ) );
        frame_guard.setLineNumber( 1016 );
        {
            PyObjectTempKeeper0 call1;
            return CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( ( call1.assign( _python_var_force_text.asObject() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_x.asObject() ) ) ).asObject(), _python_str_plain_replace ) ).asObject(), _python_str_chr_92, _python_str_digest_7f8137798425a7fed2b8c5703b70d078 ) ).asObject(), _python_str_plain_replace ) ).asObject(), _python_str_chr_37, _python_str_digest_28f423e28b5eb397034d51aaf59b708b ) ).asObject(), _python_str_plain_replace ) ).asObject(), _python_str_plain__, _python_str_digest_a0e09455d4337213cd42ebadc4d27d3b );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_x.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_force_text.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_x = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "prep_for_like_query() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "prep_for_like_query() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_x == key )
            {
                if (unlikely( _python_par_x ))
                {
                    PyErr_Format( PyExc_TypeError, "prep_for_like_query() got multiple values for keyword argument 'x'" );
                    goto error_exit;
                }

                _python_par_x = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "prep_for_like_query() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_x, key ) )
            {
                if (unlikely( _python_par_x ))
                {
                    PyErr_Format( PyExc_TypeError, "prep_for_like_query() got multiple values for keyword argument 'x'" );
                    goto error_exit;
                }

                _python_par_x = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "prep_for_like_query() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "prep_for_like_query() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "prep_for_like_query() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_x != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "prep_for_like_query() got multiple values for keyword argument 'x'" );
             goto error_exit;
         }

        _python_par_x = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_x );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_x );

    return NULL;
}

static PyObject *dparse_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );

    // Actual function code.
    static PyFrameObject *frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_1919bd3b0b9e73715862c9c5ea4a4129, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1028 );
        return _python_var_value.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "validate_autopk_value() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_autopk_value() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_autopk_value() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_autopk_value() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_autopk_value() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "validate_autopk_value() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "validate_autopk_value() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "validate_autopk_value() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "validate_autopk_value() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );

    return NULL;
}

static PyObject *dparse_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );

    // Actual function code.
    static PyFrameObject *frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_a0503d98c830824ad698e0292f402608, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1035 );
        if ( ( _python_var_value.asObject() == Py_None ) )
        {
            return INCREASE_REFCOUNT( Py_None );
        }
        frame_guard.setLineNumber( 1037 );
        {
            PyObjectTempKeeper1 call1;
            return ( call1.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_six.asObject0(), _python_str_plain_text_type ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_value.asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_date() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_date() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_date() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_date() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_date() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "value_to_db_date() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "value_to_db_date() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "value_to_db_date() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "value_to_db_date() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "value_to_db_date() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_date() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_date() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_date() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_date() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "value_to_db_date() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_date() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_date() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_date() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_date() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_date() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );

    return NULL;
}

static PyObject *dparse_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );

    // Actual function code.
    static PyFrameObject *frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_baec69f36e0cdde359d7f4ce1263a4b7, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1044 );
        if ( ( _python_var_value.asObject() == Py_None ) )
        {
            return INCREASE_REFCOUNT( Py_None );
        }
        frame_guard.setLineNumber( 1046 );
        {
            PyObjectTempKeeper1 call1;
            return ( call1.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_six.asObject0(), _python_str_plain_text_type ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_value.asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_datetime() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_datetime() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_datetime() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_datetime() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_datetime() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "value_to_db_datetime() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_datetime() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_datetime() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_datetime() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );

    return NULL;
}

static PyObject *dparse_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );

    // Actual function code.
    static PyFrameObject *frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_2b39ed0d71086479dc05c87b93cb2d5b, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1053 );
        if ( ( _python_var_value.asObject() == Py_None ) )
        {
            return INCREASE_REFCOUNT( Py_None );
        }
        frame_guard.setLineNumber( 1055 );
        {
            PyObjectTempKeeper1 call1;
            if ( CHECK_IF_TRUE( PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_timezone.asObject0(), _python_str_plain_is_aware ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_value.asObject() ) ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 1056 );
            {
                    PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_ValueError, PyObjectTemporary( MAKE_TUPLE1( _python_str_digest_b91a3fb7492cdedb10c7a237787930e4 ) ).asObject() ) );
                    RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
            }
        }
        }
        frame_guard.setLineNumber( 1057 );
        {
            PyObjectTempKeeper1 call3;
            return ( call3.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_six.asObject0(), _python_str_plain_text_type ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), _python_var_value.asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_time() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_time() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_time() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_time() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_time() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "value_to_db_time() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "value_to_db_time() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "value_to_db_time() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "value_to_db_time() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "value_to_db_time() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_time() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_time() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_time() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_time() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "value_to_db_time() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_time() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_time() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_time() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_time() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_time() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );

    return NULL;
}

static PyObject *dparse_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value, PyObject *_python_par_max_digits, PyObject *_python_par_decimal_places )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );
    PyObjectLocalParameterVariableNoDel _python_var_max_digits( _python_str_plain_max_digits, _python_par_max_digits );
    PyObjectLocalParameterVariableNoDel _python_var_decimal_places( _python_str_plain_decimal_places, _python_par_decimal_places );

    // Actual function code.
    static PyFrameObject *frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_638ef41379efe7286728fd0ad7c9cff5, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1064 );
        if ( ( _python_var_value.asObject() == Py_None ) )
        {
            return INCREASE_REFCOUNT( Py_None );
        }
        frame_guard.setLineNumber( 1066 );
        {
            PyObjectTempKeeper1 call1;
            PyObjectTempKeeper0 call2;
            PyObjectTempKeeper0 call3;
            return ( call1.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_util.asObject0(), _python_str_plain_format_number ) ), call2.assign( _python_var_value.asObject() ), call3.assign( _python_var_max_digits.asObject() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), call2.asObject0(), call3.asObject0(), _python_var_decimal_places.asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_decimal_places.updateLocalsDict( _python_var_max_digits.updateLocalsDict( _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    PyObject *_python_par_max_digits = NULL;
    PyObject *_python_par_decimal_places = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_decimal() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_max_digits == key )
            {
                if (unlikely( _python_par_max_digits ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'max_digits'" );
                    goto error_exit;
                }

                _python_par_max_digits = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_decimal_places == key )
            {
                if (unlikely( _python_par_decimal_places ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'decimal_places'" );
                    goto error_exit;
                }

                _python_par_decimal_places = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_max_digits, key ) )
            {
                if (unlikely( _python_par_max_digits ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'max_digits'" );
                    goto error_exit;
                }

                _python_par_max_digits = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_decimal_places, key ) )
            {
                if (unlikely( _python_par_decimal_places ))
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'decimal_places'" );
                    goto error_exit;
                }

                _python_par_decimal_places = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "value_to_db_decimal() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 4 ))
    {
        if ( 4 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes exactly %d arguments (%zd given)", 4, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes exactly %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#else
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes %d positional arguments but %zd were given", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 4 ))
    {
        if ( 4 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes exactly %d non-keyword arguments (%zd given)", 4, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 4 == 4 )
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes exactly %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "value_to_db_decimal() takes at least %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 4 ? args_given : 4;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_max_digits != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'max_digits'" );
             goto error_exit;
         }

        _python_par_max_digits = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_decimal_places != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "value_to_db_decimal() got multiple values for keyword argument 'decimal_places'" );
             goto error_exit;
         }

        _python_par_decimal_places = INCREASE_REFCOUNT( args[ 3 ] );
    }


    return impl_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value, _python_par_max_digits, _python_par_decimal_places );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );
    Py_XDECREF( _python_par_max_digits );
    Py_XDECREF( _python_par_decimal_places );

    return NULL;
}

static PyObject *dparse_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 4)
    {
        return impl_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );
    PyObjectLocalVariable _python_var_first( _python_str_plain_first );
    PyObjectLocalVariable _python_var_second( _python_str_plain_second );

    // Actual function code.
    static PyFrameObject *frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_d9fd8e6969f7dcbb805c59104baa0774, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1076 );
        {
            PyObjectTempKeeper1 call1;
            _python_var_first.assign1( ( call1.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_datetime.asObject0(), _python_str_plain_date ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_value.asObject(), _python_int_pos_1, _python_int_pos_1 ) ) );
        }
        frame_guard.setLineNumber( 1077 );
        {
            PyObjectTempKeeper1 call5;
            _python_var_second.assign1( ( call5.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_datetime.asObject0(), _python_str_plain_date ) ), CALL_FUNCTION_WITH_ARGS( call5.asObject0(), _python_var_value.asObject(), _python_int_pos_12, _python_int_pos_31 ) ) );
        }
        frame_guard.setLineNumber( 1078 );
        {
            PyObjectTempKeeper0 make_list9;
            return ( make_list9.assign( _python_var_first.asObject() ), MAKE_LIST2( make_list9.asObject(), _python_var_second.asObject1() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_second.updateLocalsDict( _python_var_first.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "year_lookup_bounds_for_date_field() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_date_field() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );

    return NULL;
}

static PyObject *dparse_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );
    PyObjectLocalVariable _python_var_first( _python_str_plain_first );
    PyObjectLocalVariable _python_var_second( _python_str_plain_second );
    PyObjectLocalVariable _python_var_tz( _python_str_plain_tz );

    // Actual function code.
    static PyFrameObject *frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_b86ef1f9e63eeb4bd2ffd7e87bd96c8c, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1088 );
        {
            PyObjectTempKeeper1 call1;
            _python_var_first.assign1( ( call1.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_datetime.asObject0(), _python_str_plain_datetime ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_value.asObject(), _python_int_pos_1, _python_int_pos_1 ) ) );
        }
        frame_guard.setLineNumber( 1089 );
        {
            PyObjectTempKeeper1 call5;
            _python_var_second.assign1( ( call5.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_datetime.asObject0(), _python_str_plain_datetime ) ), CALL_FUNCTION_WITH_POSARGS( call5.asObject0(), PyObjectTemporary( MAKE_TUPLE7( _python_var_value.asObject(), _python_int_pos_12, _python_int_pos_31, _python_int_pos_23, _python_int_pos_59, _python_int_pos_59, _python_int_pos_999999 ) ).asObject() ) ) );
        }
        frame_guard.setLineNumber( 1090 );
        if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_settings.asObject0(), _python_str_plain_USE_TZ ) ).asObject() ) )
        {
            frame_guard.setLineNumber( 1091 );
            _python_var_tz.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_timezone.asObject0(), _python_str_plain_get_current_timezone ) ).asObject() ) );
            frame_guard.setLineNumber( 1092 );
            {
                PyObjectTempKeeper1 call7;
                PyObjectTempKeeper0 call8;
                _python_var_first.assign1( ( call7.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_timezone.asObject0(), _python_str_plain_make_aware ) ), call8.assign( _python_var_first.asObject() ), CALL_FUNCTION_WITH_ARGS( call7.asObject0(), call8.asObject0(), _python_var_tz.asObject() ) ) );
            }
            frame_guard.setLineNumber( 1093 );
            {
                PyObjectTempKeeper1 call10;
                PyObjectTempKeeper0 call11;
                _python_var_second.assign1( ( call10.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_timezone.asObject0(), _python_str_plain_make_aware ) ), call11.assign( _python_var_second.asObject() ), CALL_FUNCTION_WITH_ARGS( call10.asObject0(), call11.asObject0(), _python_var_tz.asObject() ) ) );
            }
        }
        frame_guard.setLineNumber( 1094 );
        {
            PyObjectTempKeeper0 make_list13;
            return ( make_list13.assign( _python_var_first.asObject() ), MAKE_LIST2( make_list13.asObject(), _python_var_second.asObject1() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_tz.updateLocalsDict( _python_var_second.updateLocalsDict( _python_var_first.updateLocalsDict( PyDict_New() ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "year_lookup_bounds_for_datetime_field() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "year_lookup_bounds_for_datetime_field() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );

    return NULL;
}

static PyObject *dparse_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_value, PyObject *_python_par_field )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_value( _python_str_plain_value, _python_par_value );
    PyObjectLocalParameterVariableNoDel _python_var_field( _python_str_plain_field, _python_par_field );
    PyObjectLocalVariable _python_var_internal_type( _python_str_plain_internal_type );

    // Actual function code.
    static PyFrameObject *frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_ccdc813fe7985101bdc673353793388b, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1101 );
        if ( ( _python_var_value.asObject() == Py_None ) )
        {
            frame_guard.setLineNumber( 1102 );
            return _python_var_value.asObject1();
        }
        frame_guard.setLineNumber( 1103 );
        _python_var_internal_type.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_field.asObject(), _python_str_plain_get_internal_type ) ).asObject() ) );
        frame_guard.setLineNumber( 1104 );
        if ( RICH_COMPARE_BOOL_EQ( _python_var_internal_type.asObject(), _python_str_plain_FloatField ) )
        {
            frame_guard.setLineNumber( 1105 );
            return TO_FLOAT( _python_var_value.asObject() );
        }
        else
        {
            frame_guard.setLineNumber( 1106 );
            if ( ( CHECK_IF_TRUE( _python_var_internal_type.asObject() ) && ( CHECK_IF_TRUE( PyObjectTemporary( CALL_FUNCTION_WITH_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_internal_type.asObject(), _python_str_plain_endswith ) ).asObject(), _python_str_plain_IntegerField ) ).asObject() ) || RICH_COMPARE_BOOL_EQ( _python_var_internal_type.asObject(), _python_str_plain_AutoField ) ) ) )
            {
                frame_guard.setLineNumber( 1108 );
                return TO_INT( _python_var_value.asObject() );
            }
        }
        frame_guard.setLineNumber( 1109 );
        return _python_var_value.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_field.updateLocalsDict( _python_var_value.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_internal_type.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_value = NULL;
    PyObject *_python_par_field = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "convert_values() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_value == key )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_field == key )
            {
                if (unlikely( _python_par_field ))
                {
                    PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'field'" );
                    goto error_exit;
                }

                _python_par_field = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_value, key ) )
            {
                if (unlikely( _python_par_value ))
                {
                    PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'value'" );
                    goto error_exit;
                }

                _python_par_value = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_field, key ) )
            {
                if (unlikely( _python_par_field ))
                {
                    PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'field'" );
                    goto error_exit;
                }

                _python_par_field = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "convert_values() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "convert_values() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "convert_values() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "convert_values() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "convert_values() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "convert_values() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "convert_values() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "convert_values() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "convert_values() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "convert_values() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "convert_values() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "convert_values() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "convert_values() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_value != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'value'" );
             goto error_exit;
         }

        _python_par_value = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_field != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "convert_values() got multiple values for keyword argument 'field'" );
             goto error_exit;
         }

        _python_par_field = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_value, _python_par_field );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_value );
    Py_XDECREF( _python_par_field );

    return NULL;
}

static PyObject *dparse_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_aggregate_func )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_aggregate_func( _python_str_plain_aggregate_func, _python_par_aggregate_func );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_aggregate_func = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "check_aggregate_support() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "check_aggregate_support() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_aggregate_func == key )
            {
                if (unlikely( _python_par_aggregate_func ))
                {
                    PyErr_Format( PyExc_TypeError, "check_aggregate_support() got multiple values for keyword argument 'aggregate_func'" );
                    goto error_exit;
                }

                _python_par_aggregate_func = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "check_aggregate_support() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_aggregate_func, key ) )
            {
                if (unlikely( _python_par_aggregate_func ))
                {
                    PyErr_Format( PyExc_TypeError, "check_aggregate_support() got multiple values for keyword argument 'aggregate_func'" );
                    goto error_exit;
                }

                _python_par_aggregate_func = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "check_aggregate_support() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "check_aggregate_support() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "check_aggregate_support() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_aggregate_func != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "check_aggregate_support() got multiple values for keyword argument 'aggregate_func'" );
             goto error_exit;
         }

        _python_par_aggregate_func = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_aggregate_func );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_aggregate_func );

    return NULL;
}

static PyObject *dparse_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_connector, PyObject *_python_par_sub_expressions )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_connector( _python_str_plain_connector, _python_par_connector );
    PyObjectLocalParameterVariableNoDel _python_var_sub_expressions( _python_str_plain_sub_expressions, _python_par_sub_expressions );
    PyObjectLocalVariable _python_var_conn( _python_str_plain_conn );

    // Actual function code.
    static PyFrameObject *frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_400726a05dc61150e44518c984e9d416, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1127 );
        _python_var_conn.assign1( BINARY_OPERATION_REMAINDER( _python_str_digest_d4ac1387ebf94213a7a0a4a571390d03, _python_var_connector.asObject() ) );
        frame_guard.setLineNumber( 1128 );
        {
            PyObjectTempKeeper1 call1;
            return ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_conn.asObject(), _python_str_plain_join ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_sub_expressions.asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_sub_expressions.updateLocalsDict( _python_var_connector.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_conn.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_connector = NULL;
    PyObject *_python_par_sub_expressions = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "combine_expression() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_connector == key )
            {
                if (unlikely( _python_par_connector ))
                {
                    PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'connector'" );
                    goto error_exit;
                }

                _python_par_connector = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_sub_expressions == key )
            {
                if (unlikely( _python_par_sub_expressions ))
                {
                    PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'sub_expressions'" );
                    goto error_exit;
                }

                _python_par_sub_expressions = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_connector, key ) )
            {
                if (unlikely( _python_par_connector ))
                {
                    PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'connector'" );
                    goto error_exit;
                }

                _python_par_connector = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_sub_expressions, key ) )
            {
                if (unlikely( _python_par_sub_expressions ))
                {
                    PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'sub_expressions'" );
                    goto error_exit;
                }

                _python_par_sub_expressions = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "combine_expression() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "combine_expression() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "combine_expression() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "combine_expression() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "combine_expression() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "combine_expression() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "combine_expression() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "combine_expression() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "combine_expression() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "combine_expression() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "combine_expression() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "combine_expression() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "combine_expression() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_connector != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'connector'" );
             goto error_exit;
         }

        _python_par_connector = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_sub_expressions != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "combine_expression() got multiple values for keyword argument 'sub_expressions'" );
             goto error_exit;
         }

        _python_par_sub_expressions = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_connector, _python_par_sub_expressions );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_connector );
    Py_XDECREF( _python_par_sub_expressions );

    return NULL;
}

static PyObject *dparse_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_placeholders, PyObject *_python_par_params )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_placeholders( _python_str_plain_placeholders, _python_par_placeholders );
    PyObjectLocalParameterVariableNoDel _python_var_params( _python_str_plain_params, _python_par_params );

    // Actual function code.
    static PyFrameObject *frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) )
    {
        if ( frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
        }

        frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = MAKE_FRAME( _codeobj_c18b0bb979ca27b11ee1021fff402493, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1134 );
        return _python_var_params.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_params.updateLocalsDict( _python_var_placeholders.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends );
           frame_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_placeholders = NULL;
    PyObject *_python_par_params = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "modify_insert_params() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_placeholders == key )
            {
                if (unlikely( _python_par_placeholders ))
                {
                    PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'placeholders'" );
                    goto error_exit;
                }

                _python_par_placeholders = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_params == key )
            {
                if (unlikely( _python_par_params ))
                {
                    PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'params'" );
                    goto error_exit;
                }

                _python_par_params = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_placeholders, key ) )
            {
                if (unlikely( _python_par_placeholders ))
                {
                    PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'placeholders'" );
                    goto error_exit;
                }

                _python_par_placeholders = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_params, key ) )
            {
                if (unlikely( _python_par_params ))
                {
                    PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'params'" );
                    goto error_exit;
                }

                _python_par_params = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "modify_insert_params() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "modify_insert_params() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "modify_insert_params() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "modify_insert_params() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "modify_insert_params() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "modify_insert_params() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "modify_insert_params() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "modify_insert_params() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "modify_insert_params() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "modify_insert_params() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "modify_insert_params() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "modify_insert_params() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "modify_insert_params() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_placeholders != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'placeholders'" );
             goto error_exit;
         }

        _python_par_placeholders = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_params != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "modify_insert_params() got multiple values for keyword argument 'params'" );
             goto error_exit;
         }

        _python_par_params = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, _python_par_self, _python_par_placeholders, _python_par_params );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_placeholders );
    Py_XDECREF( _python_par_params );

    return NULL;
}

static PyObject *dparse_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



NUITKA_LOCAL_MODULE PyObject *impl_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalVariable _python_var___module__( _python_str_plain___module__ );
    PyObjectLocalVariable _python_var___doc__( _python_str_plain___doc__ );
    PyObjectLocalVariable _python_var_data_types_reverse( _python_str_plain_data_types_reverse );
    PyObjectLocalVariable _python_var___init__( _python_str_plain___init__ );
    PyObjectLocalVariable _python_var_get_field_type( _python_str_plain_get_field_type );
    PyObjectLocalVariable _python_var_table_name_converter( _python_str_plain_table_name_converter );
    PyObjectLocalVariable _python_var_table_names( _python_str_plain_table_names );
    PyObjectLocalVariable _python_var_get_table_list( _python_str_plain_get_table_list );
    PyObjectLocalVariable _python_var_django_table_names( _python_str_plain_django_table_names );
    PyObjectLocalVariable _python_var_installed_models( _python_str_plain_installed_models );
    PyObjectLocalVariable _python_var_sequence_list( _python_str_plain_sequence_list );
    PyObjectLocalVariable _python_var_get_key_columns( _python_str_plain_get_key_columns );
    PyObjectLocalVariable _python_var_get_primary_key_column( _python_str_plain_get_primary_key_column );
    PyObjectLocalVariable _python_var_get_indexes( _python_str_plain_get_indexes );

    // Actual function code.
    _python_var___module__.assign0( _python_str_plain_backends );
    _python_var___doc__.assign0( _python_str_digest_efd985803e40a7a57b16e5afd412bc06 );
    _python_var_data_types_reverse.assign1( PyDict_New() );
    _python_var___init__.assign1( MAKE_FUNCTION_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_get_field_type.assign1( MAKE_FUNCTION_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_table_name_converter.assign1( MAKE_FUNCTION_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_table_names.assign1( MAKE_FUNCTION_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_get_table_list.assign1( MAKE_FUNCTION_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_django_table_names.assign1( MAKE_FUNCTION_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_installed_models.assign1( MAKE_FUNCTION_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_sequence_list.assign1( MAKE_FUNCTION_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_get_key_columns.assign1( MAKE_FUNCTION_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_get_primary_key_column.assign1( MAKE_FUNCTION_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    _python_var_get_indexes.assign1( MAKE_FUNCTION_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
    return _python_var_get_indexes.updateLocalsDict( _python_var_get_primary_key_column.updateLocalsDict( _python_var_get_key_columns.updateLocalsDict( _python_var_sequence_list.updateLocalsDict( _python_var_installed_models.updateLocalsDict( _python_var_django_table_names.updateLocalsDict( _python_var_get_table_list.updateLocalsDict( _python_var_table_names.updateLocalsDict( _python_var_table_name_converter.updateLocalsDict( _python_var_get_field_type.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var_data_types_reverse.updateLocalsDict( _python_var___doc__.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ) ) ) );
}


static PyObject *impl_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_connection )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_connection( _python_str_plain_connection, _python_par_connection );

    // Actual function code.
    static PyFrameObject *frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_59240e1037402a7258aa77d6b6ff9f31, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1149 );
        {
                PyObject *tmp_identifier = _python_var_connection.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_connection );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_connection.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_connection = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__init__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_connection == key )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_connection, key ) )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__init__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__init__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_connection != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
             goto error_exit;
         }

        _python_par_connection = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_connection );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_connection );

    return NULL;
}

static PyObject *dparse_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_data_type, PyObject *_python_par_description )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_data_type( _python_str_plain_data_type, _python_par_data_type );
    PyObjectLocalParameterVariableNoDel _python_var_description( _python_str_plain_description, _python_par_description );

    // Actual function code.
    static PyFrameObject *frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_9b5081d71206835d4fed3cf2b2bf1a5c, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1157 );
        {
            PyObjectTempKeeper1 subscr1;
            return ( subscr1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_data_types_reverse ) ), LOOKUP_SUBSCRIPT( subscr1.asObject0(), _python_var_data_type.asObject() ) );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_description.updateLocalsDict( _python_var_data_type.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_data_type = NULL;
    PyObject *_python_par_description = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "get_field_type() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_data_type == key )
            {
                if (unlikely( _python_par_data_type ))
                {
                    PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'data_type'" );
                    goto error_exit;
                }

                _python_par_data_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_description == key )
            {
                if (unlikely( _python_par_description ))
                {
                    PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'description'" );
                    goto error_exit;
                }

                _python_par_description = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_data_type, key ) )
            {
                if (unlikely( _python_par_data_type ))
                {
                    PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'data_type'" );
                    goto error_exit;
                }

                _python_par_data_type = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_description, key ) )
            {
                if (unlikely( _python_par_description ))
                {
                    PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'description'" );
                    goto error_exit;
                }

                _python_par_description = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "get_field_type() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_field_type() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "get_field_type() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "get_field_type() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_field_type() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "get_field_type() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_field_type() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "get_field_type() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_field_type() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "get_field_type() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "get_field_type() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "get_field_type() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "get_field_type() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_data_type != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'data_type'" );
             goto error_exit;
         }

        _python_par_data_type = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_description != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_field_type() got multiple values for keyword argument 'description'" );
             goto error_exit;
         }

        _python_par_description = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_data_type, _python_par_description );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_data_type );
    Py_XDECREF( _python_par_description );

    return NULL;
}

static PyObject *dparse_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_name( _python_str_plain_name, _python_par_name );

    // Actual function code.
    static PyFrameObject *frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_df250a370c491580d2ead18b8a16efa3, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1164 );
        return _python_var_name.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_name.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "table_name_converter() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "table_name_converter() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_name == key )
            {
                if (unlikely( _python_par_name ))
                {
                    PyErr_Format( PyExc_TypeError, "table_name_converter() got multiple values for keyword argument 'name'" );
                    goto error_exit;
                }

                _python_par_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "table_name_converter() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_name, key ) )
            {
                if (unlikely( _python_par_name ))
                {
                    PyErr_Format( PyExc_TypeError, "table_name_converter() got multiple values for keyword argument 'name'" );
                    goto error_exit;
                }

                _python_par_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "table_name_converter() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "table_name_converter() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "table_name_converter() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "table_name_converter() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "table_name_converter() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "table_name_converter() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "table_name_converter() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "table_name_converter() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "table_name_converter() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "table_name_converter() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "table_name_converter() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "table_name_converter() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "table_name_converter() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "table_name_converter() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "table_name_converter() got multiple values for keyword argument 'name'" );
             goto error_exit;
         }

        _python_par_name = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_name );

    return NULL;
}

static PyObject *dparse_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );

    // Actual function code.
    static PyFrameObject *frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_48e1e75f50dd49bef77cb30d35d1ab06, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1173 );
        if ( ( _python_var_cursor.asObject() == Py_None ) )
        {
            frame_guard.setLineNumber( 1174 );
            _python_var_cursor.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_cursor ) ).asObject() ) );
        }
        frame_guard.setLineNumber( 1175 );
        {
            PyObjectTempKeeper1 call1;
            return CALL_FUNCTION_WITH_ARGS( LOOKUP_BUILTIN( _python_str_plain_sorted ), PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_get_table_list ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_cursor.asObject() ) ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "table_names() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "table_names() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "table_names() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "table_names() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "table_names() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "table_names() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "table_names() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "table_names() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "table_names() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "table_names() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "table_names() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "table_names() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "table_names() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "table_names() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "table_names() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "table_names() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "table_names() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "table_names() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "table_names() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "table_names() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_cursor == NULL )
    {
        _python_par_cursor = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_cursor );
    }


    return impl_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_cursor );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );

    return NULL;
}

static PyObject *dparse_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );

    // Actual function code.
    static PyFrameObject *frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_e14a22c6559fe4c485586b14e123ec2d, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1182 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "get_table_list() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_table_list() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "get_table_list() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_table_list() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "get_table_list() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "get_table_list() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_table_list() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "get_table_list() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "get_table_list() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_table_list() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "get_table_list() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_table_list() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "get_table_list() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_table_list() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "get_table_list() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "get_table_list() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "get_table_list() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "get_table_list() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_table_list() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_table_list() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_cursor );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );

    return NULL;
}

static PyObject *dparse_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_only_existing )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_only_existing( _python_str_plain_only_existing, _python_par_only_existing );
    PyObjectLocalVariable _python_var_models( _python_str_plain_models );
    PyObjectLocalVariable _python_var_router( _python_str_plain_router );
    PyObjectLocalVariable _python_var_tables( _python_str_plain_tables );
    PyObjectLocalVariable _python_var_app( _python_str_plain_app );
    PyObjectLocalVariable _python_var_model( _python_str_plain_model );
    PyObjectLocalVariable _python_var_existing_tables( _python_str_plain_existing_tables );
    PyObjectLocalVariable _python_var_f( _python_str_plain_f );
    PyObjectLocalVariable _python_var_t( _python_str_plain_t );

    // Actual function code.
    static PyFrameObject *frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_ff25f41519044720b4368040d982ccf1, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1192 );
        _python_var_models.assign1( IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_391c2f4b507ae374cc9606a76384636e, ((PyModuleObject *)_module_django__db__backends)->md_dict, PyObjectTemporary( _python_var_only_existing.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_t.updateLocalsDict( _python_var_f.updateLocalsDict( _python_var_existing_tables.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_tables.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ).asObject(), _python_list_str_plain_models_str_plain_router_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_models ) );
        _python_var_router.assign1( IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_391c2f4b507ae374cc9606a76384636e, ((PyModuleObject *)_module_django__db__backends)->md_dict, PyObjectTemporary( _python_var_only_existing.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_t.updateLocalsDict( _python_var_f.updateLocalsDict( _python_var_existing_tables.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_tables.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) ) ).asObject(), _python_list_str_plain_models_str_plain_router_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_router ) );
        frame_guard.setLineNumber( 1193 );
        _python_var_tables.assign1( CALL_FUNCTION_NO_ARGS( LOOKUP_BUILTIN( _python_str_plain_set ) ) );
        {
            frame_guard.setLineNumber( 1194 );
            PyObjectTemporary _python_tmp_for_iterator( MAKE_ITERATOR( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_models.asObject(), _python_str_plain_get_apps ) ).asObject() ) ).asObject() ) );
            while( true )
            {
                {
                    frame_guard.setLineNumber( 1194 );
                    PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                    if ( _tmp_unpack_1 == NULL )
                    {
                        break;
                    }
                    PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                    _python_var_app.assign0( _python_tmp_iter_value.asObject() );
                }
                {
                    frame_guard.setLineNumber( 1195 );
                    PyObject *_tmp_python_tmp_for_iterator;
                    {
                        PyObjectTempKeeper1 call1;
                        _tmp_python_tmp_for_iterator = MAKE_ITERATOR( PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_models.asObject(), _python_str_plain_get_models ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_app.asObject() ) ) ).asObject() );
                    }
                    PyObjectTemporary _python_tmp_for_iterator( _tmp_python_tmp_for_iterator );
                    while( true )
                    {
                        {
                            frame_guard.setLineNumber( 1195 );
                            PyObject *_tmp_unpack_2 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                            if ( _tmp_unpack_2 == NULL )
                            {
                                break;
                            }
                            PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_2 );
                            _python_var_model.assign0( _python_tmp_iter_value.asObject() );
                        }
                        frame_guard.setLineNumber( 1196 );
                        if ( (!( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_model.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_managed ) ).asObject() ) )) )
                        {
                            frame_guard.setLineNumber( 1197 );
                            CONSIDER_THREADING(); continue;
                        }
                        frame_guard.setLineNumber( 1198 );
                        {
                            PyObjectTempKeeper1 call3;
                            PyObjectTempKeeper1 call4;
                            if ( (!( CHECK_IF_TRUE( PyObjectTemporary( ( call3.assign( LOOKUP_ATTRIBUTE( _python_var_router.asObject(), _python_str_plain_allow_syncdb ) ), call4.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_alias ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), call4.asObject0(), _python_var_model.asObject() ) ) ).asObject() ) )) )
                        {
                            frame_guard.setLineNumber( 1199 );
                            CONSIDER_THREADING(); continue;
                        }
                        }
                        frame_guard.setLineNumber( 1200 );
                        {
                            PyObjectTempKeeper1 call6;
                            DECREASE_REFCOUNT( ( call6.assign( LOOKUP_ATTRIBUTE( _python_var_tables.asObject(), _python_str_plain_add ) ), CALL_FUNCTION_WITH_ARGS( call6.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_model.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_db_table ) ).asObject() ) ) );
                        }
                        frame_guard.setLineNumber( 1201 );
                        {
                            PyObjectTempKeeper1 call8;
                            DECREASE_REFCOUNT( ( call8.assign( LOOKUP_ATTRIBUTE( _python_var_tables.asObject(), _python_str_plain_update ) ), CALL_FUNCTION_WITH_ARGS( call8.asObject0(), PyObjectTemporary( impl_listcontr_1_of_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( MAKE_ITERATOR( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_model.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_local_many_to_many ) ).asObject() ), _python_var_f ) ).asObject() ) ) );
                        }

                       CONSIDER_THREADING();
                    }
                }

               CONSIDER_THREADING();
            }
        }
        frame_guard.setLineNumber( 1202 );
        _python_var_tables.assign1( TO_LIST( _python_var_tables.asObject() ) );
        frame_guard.setLineNumber( 1203 );
        if ( CHECK_IF_TRUE( _python_var_only_existing.asObject() ) )
        {
            frame_guard.setLineNumber( 1204 );
            _python_var_existing_tables.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_table_names ) ).asObject() ) );
            frame_guard.setLineNumber( 1205 );
            _python_var_tables.assign1( impl_listcontr_2_of_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( MAKE_ITERATOR( _python_var_tables.asObject() ), _python_var_existing_tables, _python_var_self, _python_var_t ) );
        }
        frame_guard.setLineNumber( 1210 );
        return _python_var_tables.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_only_existing.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_t.updateLocalsDict( _python_var_f.updateLocalsDict( _python_var_existing_tables.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_tables.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_only_existing = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "django_table_names() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "django_table_names() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_only_existing == key )
            {
                if (unlikely( _python_par_only_existing ))
                {
                    PyErr_Format( PyExc_TypeError, "django_table_names() got multiple values for keyword argument 'only_existing'" );
                    goto error_exit;
                }

                _python_par_only_existing = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "django_table_names() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_only_existing, key ) )
            {
                if (unlikely( _python_par_only_existing ))
                {
                    PyErr_Format( PyExc_TypeError, "django_table_names() got multiple values for keyword argument 'only_existing'" );
                    goto error_exit;
                }

                _python_par_only_existing = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "django_table_names() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "django_table_names() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "django_table_names() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "django_table_names() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "django_table_names() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "django_table_names() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "django_table_names() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "django_table_names() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "django_table_names() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "django_table_names() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "django_table_names() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "django_table_names() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "django_table_names() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "django_table_names() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_only_existing != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "django_table_names() got multiple values for keyword argument 'only_existing'" );
             goto error_exit;
         }

        _python_par_only_existing = INCREASE_REFCOUNT( args[ 1 ] );
    }
    // Assign values not given to defaults
    if ( _python_par_only_existing == NULL )
    {
        _python_par_only_existing = INCREASE_REFCOUNT( PyTuple_GET_ITEM( self->m_defaults, 0 ) );
        assertObject( _python_par_only_existing );
    }


    return impl_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_only_existing );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_only_existing );

    return NULL;
}

static PyObject *dparse_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



NUITKA_LOCAL_MODULE PyObject *impl_listcontr_1_of_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( PyObject *_python_par___iterator,PyObjectLocalVariable &python_closure_f )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var___iterator( _python_str_plain___iterator, _python_par___iterator );

    // Actual function code.
    FrameGuardVeryLight frame_guard;

    {
        PyObjectTemporary _python_tmp_result( PyList_New( 0 ) );
        {
            frame_guard.setLineNumber( 1201 );
            PyObject *_python_tmp_contraction_iter = _python_var___iterator.asObject();
            while( true )
            {
                frame_guard.setLineNumber( 1201 );
                PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_contraction_iter );

                if ( _tmp_unpack_1 == NULL )
                {
                    break;
                }
                PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                python_closure_f.assign0( _python_tmp_iter_value.asObject() );
                APPEND_TO_LIST( _python_tmp_result.asObject(), PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( python_closure_f.asObject(), _python_str_plain_m2m_db_table ) ).asObject() ) ).asObject() ), Py_None;

               CONSIDER_THREADING();
            }
        }
        return INCREASE_REFCOUNT( _python_tmp_result.asObject() );
    }
}


NUITKA_LOCAL_MODULE PyObject *impl_listcontr_2_of_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( PyObject *_python_par___iterator,PyObjectLocalVariable &python_closure_existing_tables,PyObjectLocalParameterVariableNoDel &python_closure_self,PyObjectLocalVariable &python_closure_t )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var___iterator( _python_str_plain___iterator, _python_par___iterator );

    // Actual function code.
    FrameGuardVeryLight frame_guard;

    {
        PyObjectTemporary _python_tmp_result( PyList_New( 0 ) );
        {
            frame_guard.setLineNumber( 1206 );
            PyObject *_python_tmp_contraction_iter = _python_var___iterator.asObject();
            while( true )
            {
                frame_guard.setLineNumber( 1206 );
                PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_contraction_iter );

                if ( _tmp_unpack_1 == NULL )
                {
                    break;
                }
                PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                python_closure_t.assign0( _python_tmp_iter_value.asObject() );
                {
                    PyObjectTempKeeper1 call1;
                    PyObjectTempKeeper1 cmp3;
                    if ( ( cmp3.assign( ( call1.assign( LOOKUP_ATTRIBUTE( python_closure_self.asObject(), _python_str_plain_table_name_converter ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), python_closure_t.asObject() ) ) ), SEQUENCE_CONTAINS_BOOL( cmp3.asObject0(), python_closure_existing_tables.asObject() ) ) )
                {
                    frame_guard.setLineNumber( 1206 );
                    APPEND_TO_LIST( _python_tmp_result.asObject(), python_closure_t.asObject() ), Py_None;
                }
                }

               CONSIDER_THREADING();
            }
        }
        return INCREASE_REFCOUNT( _python_tmp_result.asObject() );
    }
}


static PyObject *impl_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_tables )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_tables( _python_str_plain_tables, _python_par_tables );
    PyObjectLocalVariable _python_var_models( _python_str_plain_models );
    PyObjectLocalVariable _python_var_router( _python_str_plain_router );
    PyObjectLocalVariable _python_var_all_models( _python_str_plain_all_models );
    PyObjectLocalVariable _python_var_app( _python_str_plain_app );
    PyObjectLocalVariable _python_var_model( _python_str_plain_model );
    PyObjectLocalVariable _python_var_m( _python_str_plain_m );

    // Actual function code.
    static PyFrameObject *frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_5e493853b811945ad8da01d62bcec830, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1214 );
        _python_var_models.assign1( IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_391c2f4b507ae374cc9606a76384636e, ((PyModuleObject *)_module_django__db__backends)->md_dict, PyObjectTemporary( _python_var_tables.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_m.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_all_models.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ).asObject(), _python_list_str_plain_models_str_plain_router_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_models ) );
        _python_var_router.assign1( IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_391c2f4b507ae374cc9606a76384636e, ((PyModuleObject *)_module_django__db__backends)->md_dict, PyObjectTemporary( _python_var_tables.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_m.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_all_models.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ).asObject(), _python_list_str_plain_models_str_plain_router_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_router ) );
        _python_var_all_models.assign1( PyList_New( 0 ) );
        {
            frame_guard.setLineNumber( 1216 );
            PyObjectTemporary _python_tmp_for_iterator( MAKE_ITERATOR( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_models.asObject(), _python_str_plain_get_apps ) ).asObject() ) ).asObject() ) );
            while( true )
            {
                {
                    frame_guard.setLineNumber( 1216 );
                    PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                    if ( _tmp_unpack_1 == NULL )
                    {
                        break;
                    }
                    PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                    _python_var_app.assign0( _python_tmp_iter_value.asObject() );
                }
                {
                    frame_guard.setLineNumber( 1217 );
                    PyObject *_tmp_python_tmp_for_iterator;
                    {
                        PyObjectTempKeeper1 call1;
                        _tmp_python_tmp_for_iterator = MAKE_ITERATOR( PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_models.asObject(), _python_str_plain_get_models ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_app.asObject() ) ) ).asObject() );
                    }
                    PyObjectTemporary _python_tmp_for_iterator( _tmp_python_tmp_for_iterator );
                    while( true )
                    {
                        {
                            frame_guard.setLineNumber( 1217 );
                            PyObject *_tmp_unpack_2 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                            if ( _tmp_unpack_2 == NULL )
                            {
                                break;
                            }
                            PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_2 );
                            _python_var_model.assign0( _python_tmp_iter_value.asObject() );
                        }
                        frame_guard.setLineNumber( 1218 );
                        {
                            PyObjectTempKeeper1 call5;
                            PyObjectTempKeeper1 call6;
                            if ( CHECK_IF_TRUE( PyObjectTemporary( ( call5.assign( LOOKUP_ATTRIBUTE( _python_var_router.asObject(), _python_str_plain_allow_syncdb ) ), call6.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_alias ) ), CALL_FUNCTION_WITH_ARGS( call5.asObject0(), call6.asObject0(), _python_var_model.asObject() ) ) ).asObject() ) )
                        {
                            frame_guard.setLineNumber( 1219 );
                            {
                                PyObjectTempKeeper1 call3;
                                DECREASE_REFCOUNT( ( call3.assign( LOOKUP_ATTRIBUTE( _python_var_all_models.asObject(), _python_str_plain_append ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), _python_var_model.asObject() ) ) );
                            }
                        }
                        }

                       CONSIDER_THREADING();
                    }
                }

               CONSIDER_THREADING();
            }
        }
        frame_guard.setLineNumber( 1220 );
        {
            PyObjectTempKeeper1 call9;
            _python_var_tables.assign1( TO_LIST( PyObjectTemporary( ( call9.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_table_name_converter ) ), CALL_FUNCTION_WITH_ARGS( LOOKUP_BUILTIN( _python_str_plain_map ), call9.asObject0(), _python_var_tables.asObject() ) ) ).asObject() ) );
        }
        frame_guard.setLineNumber( 1221 );
        return CALL_FUNCTION_WITH_ARGS( LOOKUP_BUILTIN( _python_str_plain_set ), PyObjectTemporary( impl_listcontr_1_of_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( MAKE_ITERATOR( _python_var_all_models.asObject() ), _python_var_m, _python_var_self, _python_var_tables ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_tables.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_m.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_all_models.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_tables = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "installed_models() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "installed_models() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_tables == key )
            {
                if (unlikely( _python_par_tables ))
                {
                    PyErr_Format( PyExc_TypeError, "installed_models() got multiple values for keyword argument 'tables'" );
                    goto error_exit;
                }

                _python_par_tables = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "installed_models() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_tables, key ) )
            {
                if (unlikely( _python_par_tables ))
                {
                    PyErr_Format( PyExc_TypeError, "installed_models() got multiple values for keyword argument 'tables'" );
                    goto error_exit;
                }

                _python_par_tables = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "installed_models() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "installed_models() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "installed_models() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "installed_models() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "installed_models() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "installed_models() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "installed_models() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "installed_models() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "installed_models() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "installed_models() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "installed_models() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "installed_models() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "installed_models() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "installed_models() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_tables != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "installed_models() got multiple values for keyword argument 'tables'" );
             goto error_exit;
         }

        _python_par_tables = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_tables );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_tables );

    return NULL;
}

static PyObject *dparse_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



NUITKA_LOCAL_MODULE PyObject *impl_listcontr_1_of_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( PyObject *_python_par___iterator,PyObjectLocalVariable &python_closure_m,PyObjectLocalParameterVariableNoDel &python_closure_self,PyObjectLocalParameterVariableNoDel &python_closure_tables )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var___iterator( _python_str_plain___iterator, _python_par___iterator );

    // Actual function code.
    FrameGuardVeryLight frame_guard;

    {
        PyObjectTemporary _python_tmp_result( PyList_New( 0 ) );
        {
            frame_guard.setLineNumber( 1222 );
            PyObject *_python_tmp_contraction_iter = _python_var___iterator.asObject();
            while( true )
            {
                frame_guard.setLineNumber( 1222 );
                PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_contraction_iter );

                if ( _tmp_unpack_1 == NULL )
                {
                    break;
                }
                PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                python_closure_m.assign0( _python_tmp_iter_value.asObject() );
                {
                    PyObjectTempKeeper1 call1;
                    PyObjectTempKeeper1 cmp3;
                    if ( ( cmp3.assign( ( call1.assign( LOOKUP_ATTRIBUTE( python_closure_self.asObject(), _python_str_plain_table_name_converter ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( python_closure_m.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_db_table ) ).asObject() ) ) ), SEQUENCE_CONTAINS_BOOL( cmp3.asObject0(), python_closure_tables.asObject() ) ) )
                {
                    frame_guard.setLineNumber( 1222 );
                    APPEND_TO_LIST( _python_tmp_result.asObject(), python_closure_m.asObject() ), Py_None;
                }
                }

               CONSIDER_THREADING();
            }
        }
        return INCREASE_REFCOUNT( _python_tmp_result.asObject() );
    }
}


static PyObject *impl_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalVariable _python_var_models( _python_str_plain_models );
    PyObjectLocalVariable _python_var_router( _python_str_plain_router );
    PyObjectLocalVariable _python_var_apps( _python_str_plain_apps );
    PyObjectLocalVariable _python_var_sequence_list( _python_str_plain_sequence_list );
    PyObjectLocalVariable _python_var_app( _python_str_plain_app );
    PyObjectLocalVariable _python_var_model( _python_str_plain_model );
    PyObjectLocalVariable _python_var_f( _python_str_plain_f );

    // Actual function code.
    static PyFrameObject *frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_2e99745c8779724adcfb089efd37396e, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1228 );
        _python_var_models.assign1( IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_391c2f4b507ae374cc9606a76384636e, ((PyModuleObject *)_module_django__db__backends)->md_dict, PyObjectTemporary( _python_var_self.updateLocalsDict( _python_var_f.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_sequence_list.updateLocalsDict( _python_var_apps.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ).asObject(), _python_list_str_plain_models_str_plain_router_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_models ) );
        _python_var_router.assign1( IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_391c2f4b507ae374cc9606a76384636e, ((PyModuleObject *)_module_django__db__backends)->md_dict, PyObjectTemporary( _python_var_self.updateLocalsDict( _python_var_f.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_sequence_list.updateLocalsDict( _python_var_apps.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) ) ).asObject(), _python_list_str_plain_models_str_plain_router_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_router ) );
        frame_guard.setLineNumber( 1230 );
        _python_var_apps.assign1( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_models.asObject(), _python_str_plain_get_apps ) ).asObject() ) );
        _python_var_sequence_list.assign1( PyList_New( 0 ) );
        {
            frame_guard.setLineNumber( 1233 );
            PyObjectTemporary _python_tmp_for_iterator( MAKE_ITERATOR( _python_var_apps.asObject() ) );
            while( true )
            {
                {
                    frame_guard.setLineNumber( 1233 );
                    PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                    if ( _tmp_unpack_1 == NULL )
                    {
                        break;
                    }
                    PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                    _python_var_app.assign0( _python_tmp_iter_value.asObject() );
                }
                {
                    frame_guard.setLineNumber( 1234 );
                    PyObject *_tmp_python_tmp_for_iterator;
                    {
                        PyObjectTempKeeper1 call1;
                        _tmp_python_tmp_for_iterator = MAKE_ITERATOR( PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_models.asObject(), _python_str_plain_get_models ) ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_var_app.asObject() ) ) ).asObject() );
                    }
                    PyObjectTemporary _python_tmp_for_iterator( _tmp_python_tmp_for_iterator );
                    while( true )
                    {
                        {
                            frame_guard.setLineNumber( 1234 );
                            PyObject *_tmp_unpack_2 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                            if ( _tmp_unpack_2 == NULL )
                            {
                                break;
                            }
                            PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_2 );
                            _python_var_model.assign0( _python_tmp_iter_value.asObject() );
                        }
                        frame_guard.setLineNumber( 1235 );
                        if ( (!( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_model.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_managed ) ).asObject() ) )) )
                        {
                            frame_guard.setLineNumber( 1236 );
                            CONSIDER_THREADING(); continue;
                        }
                        frame_guard.setLineNumber( 1237 );
                        if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_model.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_swapped ) ).asObject() ) )
                        {
                            frame_guard.setLineNumber( 1238 );
                            CONSIDER_THREADING(); continue;
                        }
                        frame_guard.setLineNumber( 1239 );
                        {
                            PyObjectTempKeeper1 call3;
                            PyObjectTempKeeper1 call4;
                            if ( (!( CHECK_IF_TRUE( PyObjectTemporary( ( call3.assign( LOOKUP_ATTRIBUTE( _python_var_router.asObject(), _python_str_plain_allow_syncdb ) ), call4.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_connection ) ).asObject(), _python_str_plain_alias ) ), CALL_FUNCTION_WITH_ARGS( call3.asObject0(), call4.asObject0(), _python_var_model.asObject() ) ) ).asObject() ) )) )
                        {
                            frame_guard.setLineNumber( 1240 );
                            CONSIDER_THREADING(); continue;
                        }
                        }
                        {
                            frame_guard.setLineNumber( 1241 );
                            PyObjectTemporary _python_tmp_for_iterator( MAKE_ITERATOR( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_model.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_local_fields ) ).asObject() ) );
                            while( true )
                            {
                                {
                                    frame_guard.setLineNumber( 1241 );
                                    PyObject *_tmp_unpack_3 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                                    if ( _tmp_unpack_3 == NULL )
                                    {
                                        break;
                                    }
                                    PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_3 );
                                    _python_var_f.assign0( _python_tmp_iter_value.asObject() );
                                }
                                frame_guard.setLineNumber( 1242 );
                                {
                                    PyObjectTempKeeper0 isinstance12;
                                    if ( ( isinstance12.assign( _python_var_f.asObject() ), BUILTIN_ISINSTANCE_BOOL( isinstance12.asObject0(), PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_models.asObject(), _python_str_plain_AutoField ) ).asObject() ) ) )
                                {
                                    frame_guard.setLineNumber( 1243 );
                                    {
                                        PyObjectTempKeeper1 call10;
                                        PyObjectTempKeeper1 make_dict6;
                                        DECREASE_REFCOUNT( ( call10.assign( LOOKUP_ATTRIBUTE( _python_var_sequence_list.asObject(), _python_str_plain_append ) ), CALL_FUNCTION_WITH_ARGS( call10.asObject0(), PyObjectTemporary( ( make_dict6.assign( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_model.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_db_table ) ), MAKE_DICT2( make_dict6.asObject0(), _python_str_plain_table, PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_f.asObject(), _python_str_plain_column ) ).asObject(), _python_str_plain_column ) ) ).asObject() ) ) );
                                    }
                                    frame_guard.setLineNumber( 1244 );
                                    break;
                                }
                                }

                               CONSIDER_THREADING();
                            }
                        }
                        {
                            frame_guard.setLineNumber( 1246 );
                            PyObjectTemporary _python_tmp_for_iterator( MAKE_ITERATOR( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_model.asObject(), _python_str_plain__meta ) ).asObject(), _python_str_plain_local_many_to_many ) ).asObject() ) );
                            while( true )
                            {
                                {
                                    frame_guard.setLineNumber( 1246 );
                                    PyObject *_tmp_unpack_4 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                                    if ( _tmp_unpack_4 == NULL )
                                    {
                                        break;
                                    }
                                    PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_4 );
                                    _python_var_f.assign0( _python_tmp_iter_value.asObject() );
                                }
                                frame_guard.setLineNumber( 1249 );
                                if ( ( PyObjectTemporary( LOOKUP_ATTRIBUTE( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_f.asObject(), _python_str_plain_rel ) ).asObject(), _python_str_plain_through ) ).asObject() == Py_None ) )
                                {
                                    frame_guard.setLineNumber( 1250 );
                                    {
                                        PyObjectTempKeeper1 call14;
                                        DECREASE_REFCOUNT( ( call14.assign( LOOKUP_ATTRIBUTE( _python_var_sequence_list.asObject(), _python_str_plain_append ) ), CALL_FUNCTION_WITH_ARGS( call14.asObject0(), PyObjectTemporary( MAKE_DICT2( PyObjectTemporary( CALL_FUNCTION_NO_ARGS( PyObjectTemporary( LOOKUP_ATTRIBUTE( _python_var_f.asObject(), _python_str_plain_m2m_db_table ) ).asObject() ) ).asObject(), _python_str_plain_table, Py_None, _python_str_plain_column ) ).asObject() ) ) );
                                    }
                                }

                               CONSIDER_THREADING();
                            }
                        }

                       CONSIDER_THREADING();
                    }
                }

               CONSIDER_THREADING();
            }
        }
        frame_guard.setLineNumber( 1252 );
        return _python_var_sequence_list.asObject1();
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( _python_var_f.updateLocalsDict( _python_var_model.updateLocalsDict( _python_var_app.updateLocalsDict( _python_var_sequence_list.updateLocalsDict( _python_var_apps.updateLocalsDict( _python_var_router.updateLocalsDict( _python_var_models.updateLocalsDict( PyDict_New() ) ) ) ) ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "sequence_list() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_list() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "sequence_list() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "sequence_list() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "sequence_list() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "sequence_list() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "sequence_list() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "sequence_list() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_list() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "sequence_list() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_list() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "sequence_list() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "sequence_list() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "sequence_list() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "sequence_list() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "sequence_list() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "sequence_list() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor, PyObject *_python_par_table_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );
    PyObjectLocalParameterVariableNoDel _python_var_table_name( _python_str_plain_table_name, _python_par_table_name );

    // Actual function code.
    static PyFrameObject *frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_4e6a7be3c6e1531c349a1916187fad3d, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1259 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_table_name.updateLocalsDict( _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    PyObject *_python_par_table_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "get_key_columns() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_table_name == key )
            {
                if (unlikely( _python_par_table_name ))
                {
                    PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'table_name'" );
                    goto error_exit;
                }

                _python_par_table_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_table_name, key ) )
            {
                if (unlikely( _python_par_table_name ))
                {
                    PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'table_name'" );
                    goto error_exit;
                }

                _python_par_table_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "get_key_columns() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_key_columns() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "get_key_columns() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "get_key_columns() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_key_columns() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "get_key_columns() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_key_columns() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "get_key_columns() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_key_columns() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "get_key_columns() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "get_key_columns() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "get_key_columns() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "get_key_columns() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_table_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_key_columns() got multiple values for keyword argument 'table_name'" );
             goto error_exit;
         }

        _python_par_table_name = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_cursor, _python_par_table_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );
    Py_XDECREF( _python_par_table_name );

    return NULL;
}

static PyObject *dparse_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor, PyObject *_python_par_table_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );
    PyObjectLocalParameterVariableNoDel _python_var_table_name( _python_str_plain_table_name, _python_par_table_name );
    PyObjectLocalVariable _python_var_column( _python_str_plain_column );

    // Actual function code.
    static PyFrameObject *frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_e140d9c6a1e5f51784eb98975cad104a, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        {
            frame_guard.setLineNumber( 1265 );
            PyObject *_tmp_python_tmp_for_iterator;
            {
                PyObjectTempKeeper1 call1;
                PyObjectTempKeeper0 call2;
                PyObjectTempKeeper1 call4;
                _tmp_python_tmp_for_iterator = MAKE_ITERATOR( PyObjectTemporary( ( call4.assign( LOOKUP_ATTRIBUTE( _mvar_django__db__backends_six.asObject0(), _python_str_plain_iteritems ) ), CALL_FUNCTION_WITH_ARGS( call4.asObject0(), PyObjectTemporary( ( call1.assign( LOOKUP_ATTRIBUTE( _python_var_self.asObject(), _python_str_plain_get_indexes ) ), call2.assign( _python_var_cursor.asObject() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), call2.asObject0(), _python_var_table_name.asObject() ) ) ).asObject() ) ) ).asObject() );
            }
            PyObjectTemporary _python_tmp_for_iterator( _tmp_python_tmp_for_iterator );
            while( true )
            {
                {
                    frame_guard.setLineNumber( 1265 );
                    PyObject *_tmp_unpack_1 = ITERATOR_NEXT( _python_tmp_for_iterator.asObject() );

                    if ( _tmp_unpack_1 == NULL )
                    {
                        break;
                    }
                    PyObjectTemporary _python_tmp_iter_value( _tmp_unpack_1 );
                    _python_var_column.assign0( _python_tmp_iter_value.asObject() );
                }
                frame_guard.setLineNumber( 1266 );
                if ( CHECK_IF_TRUE( PyObjectTemporary( LOOKUP_SUBSCRIPT( PyObjectTemporary( LOOKUP_SUBSCRIPT_CONST( _python_var_column.asObject(), _python_int_pos_1, 1 ) ).asObject(), _python_str_plain_primary_key ) ).asObject() ) )
                {
                    frame_guard.setLineNumber( 1267 );
                    return LOOKUP_SUBSCRIPT_CONST( _python_var_column.asObject(), _python_int_0, 0 );
                }

               CONSIDER_THREADING();
            }
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_table_name.updateLocalsDict( _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( _python_var_column.updateLocalsDict( PyDict_New() ) ) ) );

        if ( frame_guard.getFrame0() == frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    PyObject *_python_par_table_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "get_primary_key_column() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_table_name == key )
            {
                if (unlikely( _python_par_table_name ))
                {
                    PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'table_name'" );
                    goto error_exit;
                }

                _python_par_table_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_table_name, key ) )
            {
                if (unlikely( _python_par_table_name ))
                {
                    PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'table_name'" );
                    goto error_exit;
                }

                _python_par_table_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "get_primary_key_column() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "get_primary_key_column() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_table_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_primary_key_column() got multiple values for keyword argument 'table_name'" );
             goto error_exit;
         }

        _python_par_table_name = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_cursor, _python_par_table_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );
    Py_XDECREF( _python_par_table_name );

    return NULL;
}

static PyObject *dparse_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_cursor, PyObject *_python_par_table_name )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_cursor( _python_str_plain_cursor, _python_par_cursor );
    PyObjectLocalParameterVariableNoDel _python_var_table_name( _python_str_plain_table_name, _python_par_table_name );

    // Actual function code.
    static PyFrameObject *frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) )
    {
        if ( frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
        }

        frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = MAKE_FRAME( _codeobj_803c21b35518b4352dbd00021197d58b, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1279 );
        RAISE_EXCEPTION_WITH_TYPE( PyExc_NotImplementedError, PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_table_name.updateLocalsDict( _python_var_cursor.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) ) );

        if ( frame_guard.getFrame0() == frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends );
           frame_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_cursor = NULL;
    PyObject *_python_par_table_name = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "get_indexes() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_cursor == key )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_table_name == key )
            {
                if (unlikely( _python_par_table_name ))
                {
                    PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'table_name'" );
                    goto error_exit;
                }

                _python_par_table_name = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_cursor, key ) )
            {
                if (unlikely( _python_par_cursor ))
                {
                    PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'cursor'" );
                    goto error_exit;
                }

                _python_par_cursor = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_table_name, key ) )
            {
                if (unlikely( _python_par_table_name ))
                {
                    PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'table_name'" );
                    goto error_exit;
                }

                _python_par_table_name = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "get_indexes() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 3 ))
    {
        if ( 3 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_indexes() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "get_indexes() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "get_indexes() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "get_indexes() takes exactly %d arguments (%zd given)", 3, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "get_indexes() takes exactly %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_indexes() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#else
            if ( 3 == 3 )
            {
                PyErr_Format( PyExc_TypeError, "get_indexes() takes %d positional arguments but %zd were given", 3, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "get_indexes() takes at most %d positional arguments (%zd given)", 3, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 3 ))
    {
        if ( 3 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "get_indexes() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "get_indexes() takes exactly %d non-keyword arguments (%zd given)", 3, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 3 == 3 )
                {
                    PyErr_Format( PyExc_TypeError, "get_indexes() takes exactly %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "get_indexes() takes at least %d arguments (%zd given)", 3, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 3 ? args_given : 3;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_cursor != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'cursor'" );
             goto error_exit;
         }

        _python_par_cursor = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_table_name != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "get_indexes() got multiple values for keyword argument 'table_name'" );
             goto error_exit;
         }

        _python_par_table_name = INCREASE_REFCOUNT( args[ 2 ] );
    }


    return impl_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, _python_par_self, _python_par_cursor, _python_par_table_name );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_cursor );
    Py_XDECREF( _python_par_table_name );

    return NULL;
}

static PyObject *dparse_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 3)
    {
        return impl_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



NUITKA_LOCAL_MODULE PyObject *impl_class_5_BaseDatabaseClient_of_module_django__db__backends(  )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalVariable _python_var___module__( _python_str_plain___module__ );
    PyObjectLocalVariable _python_var___doc__( _python_str_plain___doc__ );
    PyObjectLocalVariable _python_var_executable_name( _python_str_plain_executable_name );
    PyObjectLocalVariable _python_var___init__( _python_str_plain___init__ );
    PyObjectLocalVariable _python_var_runshell( _python_str_plain_runshell );

    // Actual function code.
    _python_var___module__.assign0( _python_str_plain_backends );
    _python_var___doc__.assign0( _python_str_digest_d215825316a7f110e8fb490a748b6791 );
    _python_var_executable_name.assign0( Py_None );
    _python_var___init__.assign1( MAKE_FUNCTION_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends(  ) );
    _python_var_runshell.assign1( MAKE_FUNCTION_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends(  ) );
    return _python_var_runshell.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var_executable_name.updateLocalsDict( _python_var___doc__.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) ) );
}


static PyObject *impl_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_connection )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_connection( _python_str_plain_connection, _python_par_connection );

    // Actual function code.
    static PyFrameObject *frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends ) )
    {
        if ( frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends );
        }

        frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends = MAKE_FRAME( _codeobj_37805757b5be6a66e331df6ac98671e8, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1293 );
        {
                PyObject *tmp_identifier = _python_var_connection.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_connection );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_connection.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends );
           frame_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_connection = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__init__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_connection == key )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_connection, key ) )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__init__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__init__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_connection != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
             goto error_exit;
         }

        _python_par_connection = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends( self, _python_par_self, _python_par_connection );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_connection );

    return NULL;
}

static PyObject *dparse_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );

    // Actual function code.
    static PyFrameObject *frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends ) )
    {
        if ( frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends );
        }

        frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends = MAKE_FRAME( _codeobj_47849a656ae0eed62d809e195163f9c4, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1296 );
        {
                PyObjectTemporary tmp_exception_type( CALL_FUNCTION_WITH_POSARGS( PyExc_NotImplementedError, _python_tuple_empty ) );
                RAISE_EXCEPTION_WITH_TYPE( tmp_exception_type.asObject(), PyObjectTemporary( MAKE_TRACEBACK( frame_guard.getFrame() ) ).asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_self.updateLocalsDict( PyDict_New() );

        if ( frame_guard.getFrame0() == frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends );
           frame_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }

}
static PyObject *fparse_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "runshell() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "runshell() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "runshell() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "runshell() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 1 ))
    {
        if ( 1 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "runshell() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "runshell() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "runshell() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "runshell() takes exactly %d arguments (%zd given)", 1, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "runshell() takes exactly %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "runshell() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#else
            if ( 1 == 1 )
            {
                PyErr_Format( PyExc_TypeError, "runshell() takes %d positional arguments but %zd were given", 1, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "runshell() takes at most %d positional arguments (%zd given)", 1, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 1 ))
    {
        if ( 1 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "runshell() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "runshell() takes exactly %d non-keyword arguments (%zd given)", 1, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 1 == 1 )
                {
                    PyErr_Format( PyExc_TypeError, "runshell() takes exactly %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "runshell() takes at least %d arguments (%zd given)", 1, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 1 ? args_given : 1;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "runshell() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }


    return impl_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends( self, _python_par_self );

error_exit:;

    Py_XDECREF( _python_par_self );

    return NULL;
}

static PyObject *dparse_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 1)
    {
        return impl_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



NUITKA_LOCAL_MODULE PyObject *impl_class_6_BaseDatabaseValidation_of_module_django__db__backends(  )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalVariable _python_var___module__( _python_str_plain___module__ );
    PyObjectLocalVariable _python_var___doc__( _python_str_plain___doc__ );
    PyObjectLocalVariable _python_var___init__( _python_str_plain___init__ );
    PyObjectLocalVariable _python_var_validate_field( _python_str_plain_validate_field );

    // Actual function code.
    _python_var___module__.assign0( _python_str_plain_backends );
    _python_var___doc__.assign0( _python_str_digest_702660732da223cb374970137d61bbe8 );
    _python_var___init__.assign1( MAKE_FUNCTION_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends(  ) );
    _python_var_validate_field.assign1( MAKE_FUNCTION_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends(  ) );
    return _python_var_validate_field.updateLocalsDict( _python_var___init__.updateLocalsDict( _python_var___doc__.updateLocalsDict( _python_var___module__.updateLocalsDict( PyDict_New() ) ) ) );
}


static PyObject *impl_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_connection )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_connection( _python_str_plain_connection, _python_par_connection );

    // Actual function code.
    static PyFrameObject *frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends = NULL;

    if ( isFrameUnusable( frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends ) )
    {
        if ( frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends )
        {
#if _DEBUG_REFRAME
            puts( "reframe for function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends" );
#endif
            Py_DECREF( frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends );
        }

        frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends = MAKE_FRAME( _codeobj_eca8af4e51b94dbe1c91e118e2a135b1, _module_django__db__backends );
    }

    FrameGuard frame_guard( frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1304 );
        {
                PyObject *tmp_identifier = _python_var_connection.asObject();
                SET_ATTRIBUTE( tmp_identifier, _python_var_self.asObject(), _python_str_plain_connection );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = _python_var_connection.updateLocalsDict( _python_var_self.updateLocalsDict( PyDict_New() ) );

        if ( frame_guard.getFrame0() == frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends )
        {
           Py_DECREF( frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends );
           frame_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends = NULL;
        }

        _exception.toPython();
        return NULL;
    }
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_connection = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "__init__() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_connection == key )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_connection, key ) )
            {
                if (unlikely( _python_par_connection ))
                {
                    PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
                    goto error_exit;
                }

                _python_par_connection = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "__init__() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 2 ))
    {
        if ( 2 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "__init__() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#else
            if ( 2 == 2 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes %d positional arguments but %zd were given", 2, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes at most %d positional arguments (%zd given)", 2, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 2 ))
    {
        if ( 2 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "__init__() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d non-keyword arguments (%zd given)", 2, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 2 == 2 )
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes exactly %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "__init__() takes at least %d arguments (%zd given)", 2, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 2 ? args_given : 2;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_connection != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "__init__() got multiple values for keyword argument 'connection'" );
             goto error_exit;
         }

        _python_par_connection = INCREASE_REFCOUNT( args[ 1 ] );
    }


    return impl_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends( self, _python_par_self, _python_par_connection );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_connection );

    return NULL;
}

static PyObject *dparse_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 2)
    {
        return impl_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}



static PyObject *impl_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject *_python_par_self, PyObject *_python_par_errors, PyObject *_python_par_opts, PyObject *_python_par_f )
{
    // No context is used.

    // Local variable declarations.
    PyObjectLocalParameterVariableNoDel _python_var_self( _python_str_plain_self, _python_par_self );
    PyObjectLocalParameterVariableNoDel _python_var_errors( _python_str_plain_errors, _python_par_errors );
    PyObjectLocalParameterVariableNoDel _python_var_opts( _python_str_plain_opts, _python_par_opts );
    PyObjectLocalParameterVariableNoDel _python_var_f( _python_str_plain_f, _python_par_f );

    // Actual function code.
    return INCREASE_REFCOUNT( Py_None );
}
static PyObject *fparse_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, Py_ssize_t args_size, PyObject *kw )
{
    assert( kw == NULL || PyDict_Check( kw ) );

    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_size = kw ? PyDict_Size( kw ) : 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_found = 0;
    NUITKA_MAY_BE_UNUSED Py_ssize_t kw_only_found = 0;
    Py_ssize_t args_given = args_size;
    PyObject *_python_par_self = NULL;
    PyObject *_python_par_errors = NULL;
    PyObject *_python_par_opts = NULL;
    PyObject *_python_par_f = NULL;
    Py_ssize_t args_usable_count;
    // Copy given dictionary values to the the respective variables:
    if ( kw_size > 0 )
    {
        Py_ssize_t ppos = 0;
        PyObject *key, *value;

        while( PyDict_Next( kw, &ppos, &key, &value ) )
        {
#if PYTHON_VERSION < 300
            if (unlikely( !PyString_Check( key ) && !PyUnicode_Check( key ) ))
#else
            if (unlikely( !PyUnicode_Check( key ) ))
#endif
            {
                PyErr_Format( PyExc_TypeError, "validate_field() keywords must be strings" );
                goto error_exit;
            }

            NUITKA_MAY_BE_UNUSED bool found = false;

            Py_INCREF( key );
            Py_INCREF( value );

            // Quick path, could be our value.
            if ( found == false && _python_str_plain_self == key )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_errors == key )
            {
                if (unlikely( _python_par_errors ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'errors'" );
                    goto error_exit;
                }

                _python_par_errors = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_opts == key )
            {
                if (unlikely( _python_par_opts ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'opts'" );
                    goto error_exit;
                }

                _python_par_opts = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && _python_str_plain_f == key )
            {
                if (unlikely( _python_par_f ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'f'" );
                    goto error_exit;
                }

                _python_par_f = value;

                found = true;
                kw_found += 1;
            }

            // Slow path, compare against all parameter names.
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_self, key ) )
            {
                if (unlikely( _python_par_self ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'self'" );
                    goto error_exit;
                }

                _python_par_self = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_errors, key ) )
            {
                if (unlikely( _python_par_errors ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'errors'" );
                    goto error_exit;
                }

                _python_par_errors = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_opts, key ) )
            {
                if (unlikely( _python_par_opts ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'opts'" );
                    goto error_exit;
                }

                _python_par_opts = value;

                found = true;
                kw_found += 1;
            }
            if ( found == false && RICH_COMPARE_BOOL_EQ_PARAMETERS( _python_str_plain_f, key ) )
            {
                if (unlikely( _python_par_f ))
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'f'" );
                    goto error_exit;
                }

                _python_par_f = value;

                found = true;
                kw_found += 1;
            }


            Py_DECREF( key );

            if ( found == false )
            {
               Py_DECREF( value );

               PyErr_Format(
                   PyExc_TypeError,
                   "validate_field() got an unexpected keyword argument '%s'",
                   Nuitka_String_Check( key ) ? Nuitka_String_AsString( key ) : "<non-string>"
               );

               goto error_exit;
            }
        }

#if PYTHON_VERSION < 300
        assert( kw_found == kw_size );
        assert( kw_only_found == 0 );
#endif
    }

    // Check if too many arguments were given in case of non star args
    if (unlikely( args_given > 4 ))
    {
        if ( 4 == 1 )
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "validate_field() takes exactly 1 argument (%zd given)", args_given + kw_found );
#elif PYTHON_VERSION < 330
            PyErr_Format( PyExc_TypeError, "validate_field() takes exactly 1 positional argument (%zd given)", args_given + kw_only_found );
#else
            PyErr_Format( PyExc_TypeError, "validate_field() takes 1 positional argument but %zd were given", args_given + kw_only_found );
#endif
        }
        else
        {
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_TypeError, "validate_field() takes exactly %d arguments (%zd given)", 4, args_given + kw_size );
#elif PYTHON_VERSION < 330
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "validate_field() takes exactly %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "validate_field() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#else
            if ( 4 == 4 )
            {
                PyErr_Format( PyExc_TypeError, "validate_field() takes %d positional arguments but %zd were given", 4, args_given + kw_only_found );
            }
            else
            {
                PyErr_Format( PyExc_TypeError, "validate_field() takes at most %d positional arguments (%zd given)", 4, args_given + kw_only_found );
            }
#endif
        }

        goto error_exit;
    }

    // Check if too little arguments were given.
    if (unlikely( args_given + kw_found - kw_only_found < 4 ))
    {
        if ( 4 == 1 )
        {
            PyErr_Format( PyExc_TypeError, "validate_field() takes exactly 1 argument (%zd given)", args_given + kw_found - kw_only_found );
        }
        else
        {
#if PYTHON_VERSION < 270
            if ( kw_size > 0 )
            {
                PyErr_Format( PyExc_TypeError, "validate_field() takes exactly %d non-keyword arguments (%zd given)", 4, args_given + kw_found  );
            }
            else
#endif
            {
                if ( 4 == 4 )
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() takes exactly %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
                else
                {
                    PyErr_Format( PyExc_TypeError, "validate_field() takes at least %d arguments (%zd given)", 4, args_given + kw_found - kw_only_found );
                }
            }
        }

        goto error_exit;
    }

    // Copy normal parameter values given as part of the args list to the respective variables:
    args_usable_count = args_given < 4 ? args_given : 4;

    if (likely( 0 < args_usable_count ))
    {
         if (unlikely( _python_par_self != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'self'" );
             goto error_exit;
         }

        _python_par_self = INCREASE_REFCOUNT( args[ 0 ] );
    }
    if (likely( 1 < args_usable_count ))
    {
         if (unlikely( _python_par_errors != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'errors'" );
             goto error_exit;
         }

        _python_par_errors = INCREASE_REFCOUNT( args[ 1 ] );
    }
    if (likely( 2 < args_usable_count ))
    {
         if (unlikely( _python_par_opts != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'opts'" );
             goto error_exit;
         }

        _python_par_opts = INCREASE_REFCOUNT( args[ 2 ] );
    }
    if (likely( 3 < args_usable_count ))
    {
         if (unlikely( _python_par_f != NULL ))
         {
             PyErr_Format( PyExc_TypeError, "validate_field() got multiple values for keyword argument 'f'" );
             goto error_exit;
         }

        _python_par_f = INCREASE_REFCOUNT( args[ 3 ] );
    }


    return impl_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends( self, _python_par_self, _python_par_errors, _python_par_opts, _python_par_f );

error_exit:;

    Py_XDECREF( _python_par_self );
    Py_XDECREF( _python_par_errors );
    Py_XDECREF( _python_par_opts );
    Py_XDECREF( _python_par_f );

    return NULL;
}

static PyObject *dparse_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends( Nuitka_FunctionObject *self, PyObject **args, int size )
{
    if ( size == 4)
    {
        return impl_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends( self, INCREASE_REFCOUNT( args[ 0 ] ), INCREASE_REFCOUNT( args[ 1 ] ), INCREASE_REFCOUNT( args[ 2 ] ), INCREASE_REFCOUNT( args[ 3 ] ) );
    }
    else
    {
        PyObject *result = fparse_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends( self, args, size, NULL );
        return result;
    }

}




static PyObject *MAKE_FUNCTION_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_10_datetime_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_datetime_trunc_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_09169b36c58f2d3b6695e7e432c031e9,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_8a74ecddf9a51d4697e2c75e3b9b9045
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_10_ensure_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_ensure_connection,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_0ec3e7a604a102e6829567f33d26f2eb,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_9ce7d38251b90ae98994d81cb6dd4a49
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_10_get_primary_key_column_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_get_primary_key_column,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_e140d9c6a1e5f51784eb98975cad104a,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_33adc5fffe678af14c998c85220cb05e
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_11__cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__cursor,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_174058353f799e58cf8ca1b5f3ef9c68,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_11_deferrable_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_deferrable_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_564c7496512a9d6367bd830c971ce668,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_d9bb39a48cbd204f6f741a3bd2a385aa
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_11_get_indexes_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_get_indexes,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_803c21b35518b4352dbd00021197d58b,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_0762318ba956d18d8044265c2cffa825
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_12__commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__commit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_c883c8871ccc377b1d93403ca0ce582d,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_12_distinct_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_distinct_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_2ca7cb49e299b7712fffe89e6f824e6b,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_b187f39496c3da1148347cad9cf83f42
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_13__rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__rollback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_a7061a404e963f5afac433a3c2a9ad4f,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_13_drop_foreignkey_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_drop_foreignkey_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_bc543a26bd5d80fa0dd8373b07fe59bc,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_71274f9ceff14065e78f40517a58a0c6
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_14__close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__close,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_6e09fa3ef8b9ec4470e3fda9f0224fe7,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_14_drop_sequence_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_drop_sequence_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_1769a8565d9708491f9c0131aa84df8e,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_cfa374e6e5dc29e89e9276acb8382550
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_15_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_cursor,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_ea2848d8dd09abe4069bee2edaa61c23,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_03c4f0d58faa60656e85b270d9a5b1a9
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_15_fetch_returned_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_fetch_returned_insert_id,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_a8a419bd891b90451fbe260ae3eb5efc,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_dc3deee9810cc976cd45b3f4b179d823
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_16_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_commit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_a051cea9086ed3bf893fa50fb77700d9,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_010f86465b1a8c0b7129311591b45d2c
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_16_field_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_field_cast_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_acdf2f81668eada3c96bccdf40476bce,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_3492f962e9cd1811c5a834b91c5fda1e
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_17_force_no_ordering_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_force_no_ordering,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_cc8364c4928fc9303740175117bace39,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_23871166bbdfe5386f569389d09ca601
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_17_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_rollback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_4fe5cba5560e946bc359afe5336cc8f5,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_96b877441740c77d05993502ca95d2b0
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_18_close_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_close,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_9366b66efe29463c9b853457607bef10,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_e995e8096aea3979e93b8b9c481a7c53
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_18_for_update_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_for_update_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_7d7157576e138895029be58f9c1f6fea,
        INCREASE_REFCOUNT( _python_tuple_false_tuple ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_706516b89fbe004504f8506f0a930f28
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_19__savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__savepoint,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_bb395879407e89ab514c7e21bab2ab0b,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_19_fulltext_search_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_fulltext_search_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_c80db662812006058d356668a727f708,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_b56fe8a6a46d2c4b7172c96eef82ccc7
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_1___init___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_bfe4a65ea4b8b62558a8c1f1cfeb19b3,
        defaults,
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends,
        dparse_function_1___init___of_class_2_BaseDatabaseFeatures_of_module_django__db__backends,
        _python_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_02846dab0c1846b289b096934185fb93,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_1___init___of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_6a99f00dea99dbeeaefed77440a3af8b,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_1___init___of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_59240e1037402a7258aa77d6b6ff9f31,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends,
        dparse_function_1___init___of_class_5_BaseDatabaseClient_of_module_django__db__backends,
        _python_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_37805757b5be6a66e331df6ac98671e8,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends,
        dparse_function_1___init___of_class_6_BaseDatabaseValidation_of_module_django__db__backends,
        _python_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_eca8af4e51b94dbe1c91e118e2a135b1,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_20__savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__savepoint_rollback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_2d8099ead333d11a4118447c2b713f27,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_last_executed_query,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_cdbcca214430403cb9d500ba4c73a5d7,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_06697c62127530aacc794c6641cf4c4c
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_21__savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__savepoint_commit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_6a85106c13f3f4ea39cf584ff76b3349,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_21_last_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_last_insert_id,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_b45cf12a4d3734a644bcb40e2fe9df27,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_74fdce9e3fc77f33633ce80450cc429a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_22__savepoint_allowed_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__savepoint_allowed,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_b2d58942ed67bc577fb7ac25f46c02bf,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_22_lookup_cast_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_lookup_cast,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_92565b7ef8103291dca3fefac6a04dc1,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_3fb6fc90b762bd2cec7fb3c57def597b
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_23_max_in_list_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_max_in_list_size,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_b79bcb83a75bec783ac2306383d5422f,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_a3284475c8926ce087a424d2b497f48a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_23_savepoint_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_savepoint,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_ca0a51ea0e1138cf11227618d1754d22,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_99efbe0ab305d2d5c5ab7f39fcfc39db
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_24_max_name_length_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_max_name_length,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_6dd2e8b9827cde95bcfde20aa7367819,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_0544f5168d27ee8e4abb9b89535d3268
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_24_savepoint_rollback_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_savepoint_rollback,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_e477969a3b99ca32a38e82748774b370,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_8fd4644e099aae5a082279f876c83740
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_25_no_limit_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_no_limit_value,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_95148283ed1d9f6430dbc75efd943da4,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_018259584a69a4f42f750e2fdab5c271
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_25_savepoint_commit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_savepoint_commit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_255a66cf84f179184570e486049da0c6,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_cc74fca2c6d251eb3246d5f74c8bf70a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_26_clean_savepoints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_clean_savepoints,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_71b6366f77ee9899c9ef82b59e499594,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_6eb649e28c89f80f65e0e57b3fd358c4
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_26_pk_default_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_pk_default_value,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_b14fb41738da426ca622296ce6af1b45,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_0b99df1aa6ecc071304c24e12bc2ec4d
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_27__set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__set_autocommit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_ce8dc9cc96f21d45ef26c6feac40a1cf,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_404ca3c5a32dce92dc648d338f824dbc
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_27_process_clob_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_process_clob,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_c3d627ca9aa8af38487dfe64f8f3264d,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_04d4ef560c50cd29fd43cc82454ab3a4
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_28_enter_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_enter_transaction_management,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_30b6ca1ebd0b184998958ab5824147a2,
        INCREASE_REFCOUNT( _python_tuple_true_false_tuple ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_5b957f52733ef1036ea06c0ea5fd6520
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_28_return_insert_id_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_return_insert_id,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_eee1671b7752e5a45c53d7f4d3750e64,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_4d68fdc9eb54b000a1974f711e63a000
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_29_compiler_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_compiler,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_dfb000688c0f14972c0ebe8762dc8710,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_646ac13563b4994d17a5531cf73aa7a6
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_29_leave_transaction_management_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_leave_transaction_management,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_a3317b0bb44eabe1aa0c11eb1a8ac30d,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_60831a1cd1caa60c640b2f63c2374b42
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_2___eq___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain___eq__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_44831b8e2eac21cb1519f8e0f0588afe,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_2_autoinc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_autoinc_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_cd24983dc044142bf729ee3948fe855f,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_b018a6870cf9594e5fff0cc8a7e7b7ab
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_2_get_field_type_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_get_field_type,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_9b5081d71206835d4fed3cf2b2bf1a5c,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_fcdcb6d00783728137fed5f88efba4de
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends,
        dparse_function_2_runshell_of_class_5_BaseDatabaseClient_of_module_django__db__backends,
        _python_str_plain_runshell,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_47849a656ae0eed62d809e195163f9c4,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends,
        dparse_function_2_supports_transactions_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends,
        _python_str_plain_supports_transactions,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_70e43d0b8b48f51645e968e54e0404fb,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_cf1f40813628f2628ba29d1cf196d9ad
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends,
        dparse_function_2_validate_field_of_class_6_BaseDatabaseValidation_of_module_django__db__backends,
        _python_str_plain_validate_field,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_321d2798bf2e07db960a28d73845e598,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_38188aeaefddf09eab54fd15341fc0ec
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_30_quote_name_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_quote_name,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_7b8c0f99645a001cab8018fee70ca93a,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_c055dc363edb397c7da7569aa665d036
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_30_set_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_set_autocommit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_538c066319d49732e3bd6578639e9ea2,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_5cc50a162fb8416dc274976ae8a7ac5f
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_31_random_function_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_random_function_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_092534a360393e8e542d885e7460b2da,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_c768c4900cb20496ec051d59ae86796e
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_31_validate_no_atomic_block_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_validate_no_atomic_block,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_6e34eed68125dff5ca29c65a79ea7acf,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_8a0d444670d550da2d891efd2bf44819
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_32_abort_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_abort,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_43c761f38f1eecffeefcaaee1d88e1c8,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_8cff4adfbf8bd5cf9e082e6ed50bc289
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_32_regex_lookup_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_regex_lookup,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_9fbdf013283ffb39f5464e3b36b8e695,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_1be6100979315b8896cb005796758b59
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_33_is_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_is_dirty,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_299f7d78cbab83e4a95c219e54ca3e93,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_9b6b8fd8aaa03c896bdf9996b21a15a7
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_33_savepoint_create_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_savepoint_create_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_4b8bb88f4c652de38f1188014360aa1e,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_f97786b13b5fb4153e22eee5ee4dacc8
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_34_savepoint_commit_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_savepoint_commit_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_90b90a54eb6c8f017d4d704fba8f94bc,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_2c6848ea9f067ce5816e28ae373a9fc7
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_34_set_dirty_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_set_dirty,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_c0340cc4d08afb26d20c3c6e29eeac13,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_f41fcf242ad843c09f73b015b20b50a5
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_35_savepoint_rollback_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_savepoint_rollback_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_da364956461cf6368aed8818de0359a0,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_0b07e1a4a20e480b5f34b8e5a9f1588c
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_35_set_clean_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_set_clean,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_7925c1cd796c69b346159488432bcabf,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_d5007156a0fd23bf64491f9b0a604be5
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    return Nuitka_Function_New(
        fparse_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_36_constraint_checks_disabled_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_constraint_checks_disabled,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_0d86529430a7b6aa511fc15f24a0a047,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_97ed4f3c3b9844d23367315b1d8e7233
    );
}



static PyObject *MAKE_FUNCTION_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_36_set_time_zone_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_set_time_zone_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_05a50f047659887dedb2a1c7810c8fe9,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_1773bc8ceaee6dc1824e8ce79a2ca34b
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_37_disable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_disable_constraint_checking,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_0256a7d7807894b8e1fe0d3604bb6fc2,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_ddeb33489f58ac699541a9db12396e66
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_37_sql_flush_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_sql_flush,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_18acb977c380db3ac80c79e6488b6050,
        INCREASE_REFCOUNT( _python_tuple_false_tuple ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_3ed45d17dc6ef144bc93d69415c1fea2
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_38_enable_constraint_checking_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_enable_constraint_checking,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_ccc12ed1d419747b67a9793259d26964,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_8e6e613c7186cccfbfdaa1905f425ee8
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_38_sequence_reset_by_name_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_sequence_reset_by_name_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_a3d7ab2f41a293d00dbed3cbbccf50f1,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_7d44e8e318cb8b7da584a76bef4a3e0f
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_39_check_constraints_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_check_constraints,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_94f7dcd8f5bb18ebe849593dfb995e50,
        INCREASE_REFCOUNT( _python_tuple_none_tuple ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_19921a9f67db7bd00f829b7b1cfce1c0
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_39_sequence_reset_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_sequence_reset_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_4c6ffa94a7510880a8a48d2b9b82fbb9,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_f32c9e38770c1b9f080878acfffc054e
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_3___ne___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain___ne__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_3eaba9864b17af6a5b96bdcaf5895269,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_3_bulk_batch_size_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_bulk_batch_size,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_e84ed2df3bc6f767e025bec789b2e67e,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_b3499dba8b3842aec8ebff484dd68e04
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends,
        dparse_function_3_supports_stddev_of_class_2_BaseDatabaseFeatures_of_module_django__db__backends,
        _python_str_plain_supports_stddev,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_3eec6de8e6560d9ca3138b7974f3d129,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_3d37bafc183c7699a9eada34a10e3769
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_3_table_name_converter_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_table_name_converter,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_df250a370c491580d2ead18b8a16efa3,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_40e69f11e0c82892648fc59d45dc383a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_40_is_usable_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_is_usable,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_f68eddb5d24db2f1d885c40adbb06ce5,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_d31b872f5b289b3d2d182078e4a6f300
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_40_start_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_start_transaction_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_477bff3bcc5a68e841ec48f0601c3cf4,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_e9bb22a75b8e8085c482037f55f552d6
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_41_close_if_unusable_or_obsolete_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_close_if_unusable_or_obsolete,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_e620b824cf080d4c4459517cfff1a786,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_3d04c5b01d0e6b6a47a42ad044d90501
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_41_end_transaction_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_end_transaction_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_e2b49dc185aa7db41f64acc0099223c0,
        INCREASE_REFCOUNT( _python_tuple_true_tuple ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_e318b97ebcdfa4a08a8b96e4ee5276ea
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_42_tablespace_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_tablespace_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_0780c240343a97bd4a686c82c4f25845,
        INCREASE_REFCOUNT( _python_tuple_false_tuple ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_c1b38363208bc7272c9950b0d0bb29e7
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_42_validate_thread_sharing_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_validate_thread_sharing,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_623f58120be42ce03c560a1bd9fa081b,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_b352aa1bca8842403766f2bf03aba9a4
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_43_prep_for_like_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_prep_for_like_query,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_1a09a9a082aa896d786097b003e90283,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_0b9b44c4ababf7708a1cbc2bf57e3140
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_43_wrap_database_errors_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_wrap_database_errors,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_8aabc962a7bb04b21437bcd1e0359c4a,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_8844c31c40259b2b174586b6d2670e24
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_44_make_debug_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_make_debug_cursor,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_a63252ab3f76515025c705fb22cc76ca,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_7ce1b2bf5b8ffe5526c40765c439f2df
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_44_validate_autopk_value_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_validate_autopk_value,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_1919bd3b0b9e73715862c9c5ea4a4129,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_1c464ae06ab689659ce808690bea7d10
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    return Nuitka_Function_New(
        fparse_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_45_temporary_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_temporary_connection,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_6212400ff9fddc80a694d7367ced1009,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_62ac65d5f1611225ddb8db96f805d2cb
    );
}



static PyObject *MAKE_FUNCTION_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_45_value_to_db_date_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_value_to_db_date,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_a0503d98c830824ad698e0292f402608,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_9bf3da0ffaa29718f090db1b40555a4e
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_46__start_transaction_under_autocommit_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain__start_transaction_under_autocommit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_439485a6ce95b942ceb8216ad2478504,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_7847af0f380287ee0daf1f677549fef3
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_46_value_to_db_datetime_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_value_to_db_datetime,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_baec69f36e0cdde359d7f4ce1263a4b7,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_05f82150d1071f26395059cb87151eae
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_47_value_to_db_time_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_value_to_db_time,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_2b39ed0d71086479dc05c87b93cb2d5b,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_f1ae29a948c2ccf501bc2f1cbfa8ea4d
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_48_value_to_db_decimal_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_value_to_db_decimal,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_638ef41379efe7286728fd0ad7c9cff5,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_edc99d306fc438861ac3f50674a077f4
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_49_year_lookup_bounds_for_date_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_year_lookup_bounds_for_date_field,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_d9fd8e6969f7dcbb805c59104baa0774,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_d5c0463a8c0a45256692b70f6a8da163
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_4___hash___of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain___hash__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_92ff8da4debc05ba9f7e6fd46141cb66,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_4_cache_key_culling_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_cache_key_culling_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_5c86c21ebe435300072bb990cfcbcf81,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_e5dc64171586412a690ba6ad268ed97e
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_4_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_table_names,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_48e1e75f50dd49bef77cb30d35d1ab06,
        INCREASE_REFCOUNT( _python_tuple_none_tuple ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_2ac06d0f09bc690390a6e5b82b5aaaf4
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_50_year_lookup_bounds_for_datetime_field_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_year_lookup_bounds_for_datetime_field,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_b86ef1f9e63eeb4bd2ffd7e87bd96c8c,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_a7ca8d605da68c6cd7b34c2da549b63a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_51_convert_values_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_convert_values,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_ccdc813fe7985101bdc673353793388b,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_3c7924ddb01b5421cc7df6d9986950dd
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_52_check_aggregate_support_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_check_aggregate_support,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_e600b5b5acab0237c19bf72986ac4580,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_26485fb033efcc106f2fddff908e54eb
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_53_combine_expression_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_combine_expression,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_400726a05dc61150e44518c984e9d416,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_175fe870e0ba0d3fd43c6a51c7b0bbcd
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_54_modify_insert_params_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_modify_insert_params,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_c18b0bb979ca27b11ee1021fff402493,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_6a2d74248087f97dab1fe5bec0d48258
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_5_date_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_date_extract_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_394b1b895b503510d6a8250e3b9ef11f,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_a8e388f63c6e0c0710966e94c43f78bc
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_5_get_connection_params_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_get_connection_params,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_536fd37005ad9fe8f34cb0a5e7204ae4,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_c5ee79589792be03dd160dda056823f6
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_5_get_table_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_get_table_list,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_e14a22c6559fe4c485586b14e123ec2d,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_c3cf9c56914c765a96c3d446b44374ce
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_6_date_interval_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_date_interval_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_92254d74c78bf1151343d5a6fdd49033,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_9f3a12b5faefbe31efc9d624da053f57
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_6_django_table_names_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_django_table_names,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_ff25f41519044720b4368040d982ccf1,
        INCREASE_REFCOUNT( _python_tuple_false_tuple ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_8287ede1700fb95111a8dc314a61dde8
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_6_get_new_connection_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_get_new_connection,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_5b83f38c6e6c935b21b38ec6061eeb99,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_74683ea3f2fef63c587b2afa39617ebc
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_7_date_trunc_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_date_trunc_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_ac08f3c67b2503e5bc57a154cf12298c,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_ded469bae12d23a000a1a78fe0083267
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_7_init_connection_state_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_init_connection_state,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_a64ef9553db5b1a6addd0b8c96dd5d0d,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_20d261dd3da20535691773a916f4c9c7
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_7_installed_models_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_installed_models,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_5e493853b811945ad8da01d62bcec830,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_827f7661f02c9a8d101aae492ad16a77
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_8_create_cursor_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_create_cursor,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_560bb2051560de40ae148c9c1556c32a,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_96723f361de2c405742ddd1b373e7131
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_8_datetime_cast_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_datetime_cast_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_81c649de5d23ecd4da1780e2e4a15937,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_cc5b2efc8e167b6b2aa0d36f4b2fb836
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_8_sequence_list_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_sequence_list,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_2e99745c8779724adcfb089efd37396e,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_5a275534ce136fb1192acfe1aae44cb2
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        dparse_function_9_connect_of_class_1_BaseDatabaseWrapper_of_module_django__db__backends,
        _python_str_plain_connect,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_53fd8ad664daa59fe1b5a5668630caa5,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_98592bec0618144637e5a11ccaf626c6
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_function_9_datetime_extract_sql_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_plain_datetime_extract_sql,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_c4254974ffce4639bd91d4b58814332f,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_5b4f647bfb55d826905fec30a8facc4b
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  )
{
    PyObject *result = Nuitka_Function_New(
        fparse_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        dparse_function_9_get_key_columns_of_class_4_BaseDatabaseIntrospection_of_module_django__db__backends,
        _python_str_plain_get_key_columns,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_4e6a7be3c6e1531c349a1916187fad3d,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        _python_str_digest_8d2634dae244fe5f0b895c3800f4d533
    );

    return result;
}



static PyObject *MAKE_FUNCTION_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends( PyObjectSharedLocalVariable &python_closure_force_text )
{
    struct _context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t *_python_context = new _context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_t;

    // Copy the parameter default values and closure values over.
    _python_context->python_closure_force_text.shareWith( python_closure_force_text );

    PyObject *result = Nuitka_Function_New(
        fparse_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        dparse_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends,
        _python_str_angle_lambda,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        _codeobj_e7f0ad9b8d147e593177147d187993d4,
        INCREASE_REFCOUNT( Py_None ),
#if PYTHON_VERSION >= 300
        INCREASE_REFCOUNT( Py_None ),
        NULL,
#endif
        _module_django__db__backends,
        Py_None,
        _python_context,
        _context_lambda_1_lambda_of_function_20_last_executed_query_of_class_3_BaseDatabaseOperations_of_module_django__db__backends_destructor
    );

    return result;
}


#if PYTHON_VERSION >= 300
static struct PyModuleDef _moduledef =
{
    PyModuleDef_HEAD_INIT,
    "django.db.backends",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

#define _MODULE_UNFREEZER 0

#if _MODULE_UNFREEZER
// For embedded modules, to be unpacked. Used by main program/package only
extern void registerMetaPathBasedUnfreezer( struct _inittab *_frozen_modules );

// Our own inittab for lookup of "frozen" modules, i.e. the ones included in this binary.
static struct _inittab _frozen_modules[] =
{

    { NULL, NULL }
};

// For loader attribute.
#if PYTHON_VERSION >= 330
extern PyObject *loader_frozen_modules;
#endif

#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( django__db__backends )
{

#if defined( _NUITKA_EXE ) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Packages can be imported recursively in deep executables.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( _module_django__db__backends );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    _initConstants();

    // Initialize the compiled types of Nuitka.
    PyType_Ready( &Nuitka_Generator_Type );
    PyType_Ready( &Nuitka_Function_Type );
    PyType_Ready( &Nuitka_Method_Type );
    PyType_Ready( &Nuitka_Frame_Type );

    patchInspectModule();

    patchBuiltinModule();
#endif

#if _MODULE_UNFREEZER
    registerMetaPathBasedUnfreezer( _frozen_modules );
#endif

    // puts( "in initdjango__db__backends" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    _module_django__db__backends = Py_InitModule4(
        "django.db.backends",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No __doc__ is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    _module_django__db__backends = PyModule_Create( &_moduledef );
#endif

    _moduledict_django__db__backends = (PyDictObject *)((PyModuleObject *)_module_django__db__backends)->md_dict;

    assertObject( _module_django__db__backends );

#ifndef _NUITKA_MODULE
// Seems to work for Python2.7 out of the box, but for Python3.2, the module
// doesn't automatically enter "sys.modules" with the object that it should, so
// do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), _python_str_digest_67631acd3c65ad614c0beb0db7bbe60a, _module_django__db__backends );

        assert( r != -1 );
    }
#endif
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    PyObject *module_dict = PyModule_GetDict( _module_django__db__backends );

    if ( PyDict_GetItem( module_dict, _python_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = ( PyObject *)module_builtin;

#ifdef _NUITKA_EXE
        if ( _module_django__db__backends != _module___main__ )
        {
#endif
            value = PyModule_GetDict( value );
#ifdef _NUITKA_EXE
        }
#endif

#ifndef __NUITKA_NO_ASSERT__
        int res =
#endif
            PyDict_SetItem( module_dict, _python_str_plain___builtins__, value );

        assert( res == 0 );
    }

#if PYTHON_VERSION >= 330
#if _MODULE_UNFREEZER
    PyDict_SetItem( module_dict, _python_str_plain___loader__, loader_frozen_modules );
#else
    PyDict_SetItem( module_dict, _python_str_plain___loader__, Py_None );
#endif
#endif

    // Module code
    UPDATE_STRING_DICT0( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain___doc__, Py_None );
    UPDATE_STRING_DICT0( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain___file__, _python_str_digest_89c0d2d16137e3b07e127b636f9086d8 );
    UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain___path__, LIST_COPY( _python_list_str_digest_c6cf74304a000d55cfcdcdf3a62ee264_list ) );
    PyFrameObject *frame_module_django__db__backends = MAKE_FRAME( _codeobj_361e991870bf9934e936d24a8860e341, _module_django__db__backends );

    FrameGuard frame_guard( frame_module_django__db__backends );
    try
    {
        assert( Py_REFCNT( frame_module_django__db__backends ) == 2 ); // Frame stack
        frame_guard.setLineNumber( 1 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_datetime, IMPORT_MODULE( _python_str_plain_datetime, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, Py_None, _python_int_neg_1 ) );
        frame_guard.setLineNumber( 2 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_time, IMPORT_MODULE( _python_str_plain_time, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, Py_None, _python_int_neg_1 ) );
        frame_guard.setLineNumber( 4 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_DatabaseError, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_3d07a776757bf1a03cf12370baf54363, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_DatabaseError_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_DatabaseError ) );
        frame_guard.setLineNumber( 6 );
        try
        {
            frame_guard.setLineNumber( 7 );
            UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_thread, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_91ddc8f1df73e2bf4268fd2741c1c593, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain__thread_list, _python_int_neg_1 ) ).asObject(), _python_str_plain__thread ) );
        }
        catch ( PythonException &_exception )
        {
            if ( !_exception.hasTraceback() )
            {
                _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
            }
            else
            {
                _exception.addTraceback( frame_guard.getFrame0() );
            }

            frame_guard.preserveExistingException();

#if PYTHON_VERSION >= 300
            ExceptionRestorerFrameGuard restorer( &frame_guard );
#endif
            _exception.toExceptionHandler();

            if ( _exception.matches( PyExc_ImportError ) )
            {
                frame_guard.detachFrame();
                frame_guard.setLineNumber( 9 );
                UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_thread, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_91ddc8f1df73e2bf4268fd2741c1c593, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain__dummy_thread_list, _python_int_neg_1 ) ).asObject(), _python_str_plain__dummy_thread ) );
            }
            else
            {
                PyTracebackObject *tb = _exception.getTraceback();
                frame_guard.setLineNumber( tb->tb_lineno );
                _exception.setTraceback( tb->tb_next );
                tb->tb_next = NULL;

                throw;
            }
        }
        frame_guard.setLineNumber( 10 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_namedtuple, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_plain_collections, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_namedtuple_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_namedtuple ) );
        frame_guard.setLineNumber( 11 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_contextmanager, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_plain_contextlib, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_contextmanager_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_contextmanager ) );
        frame_guard.setLineNumber( 13 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_settings, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_262bd828f67160809670905d543ae3a0, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_settings_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_settings ) );
        frame_guard.setLineNumber( 14 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_DEFAULT_DB_ALIAS, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_391c2f4b507ae374cc9606a76384636e, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_DEFAULT_DB_ALIAS_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_DEFAULT_DB_ALIAS ) );
        frame_guard.setLineNumber( 15 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_connection_created, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_2d1b41e79431b59e918eb9f76aa47ae5, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_connection_created_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_connection_created ) );
        frame_guard.setLineNumber( 16 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_util, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_67631acd3c65ad614c0beb0db7bbe60a, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_util_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_util ) );
        frame_guard.setLineNumber( 17 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_TransactionManagementError, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_cf8e94c0a68dd5fab8d5a5ad609e11e4, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_TransactionManagementError_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_TransactionManagementError ) );
        frame_guard.setLineNumber( 18 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_DatabaseErrorWrapper, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_3d07a776757bf1a03cf12370baf54363, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_DatabaseErrorWrapper_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_DatabaseErrorWrapper ) );
        frame_guard.setLineNumber( 19 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_cached_property, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_17c58b9ed63e22a2fe75ba31286ba1f7, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_cached_property_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_cached_property ) );
        frame_guard.setLineNumber( 20 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_import_module, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_4fc502edf9b4c184659c220d993c01d3, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_import_module_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_import_module ) );
        frame_guard.setLineNumber( 21 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_six, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_11a3eb3229bb1ce81f02aa3fc01149d5, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_six_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_six ) );
        frame_guard.setLineNumber( 22 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_timezone, IMPORT_NAME( PyObjectTemporary( IMPORT_MODULE( _python_str_digest_11a3eb3229bb1ce81f02aa3fc01149d5, ((PyModuleObject *)_module_django__db__backends)->md_dict, ((PyModuleObject *)_module_django__db__backends)->md_dict, _python_list_str_plain_timezone_list, _python_int_neg_1 ) ).asObject(), _python_str_plain_timezone ) );
        {
            frame_guard.setLineNumber( 25 );
            PyObjectTemporary _python_tmp_bases( MAKE_TUPLE1( LOOKUP_BUILTIN( _python_str_plain_object ) ) );
            PyObjectTemporary _python_tmp_class_dict( impl_class_1_BaseDatabaseWrapper_of_module_django__db__backends(  ) );
            PyObjectTemporary _python_tmp_metaclass( ( SEQUENCE_CONTAINS_BOOL( _python_str_plain___metaclass__, _python_tmp_class_dict.asObject() ) ? DICT_GET_ITEM( _python_tmp_class_dict.asObject(), _python_str_plain___metaclass__ ) : SELECT_METACLASS( _python_tmp_bases.asObject(), ( _mvar_django__db__backends___metaclass__.isInitialized( false ) ? _mvar_django__db__backends___metaclass__.asObject0() : NULL ) ) ) );
            PyObject *_tmp_python_tmp_class;
            {
                PyObjectTempKeeper0 call1;
                PyObjectTempKeeper0 call3;
                _tmp_python_tmp_class = ( call1.assign( _python_tmp_metaclass.asObject() ), call3.assign( _python_tmp_bases.asObject() ), CALL_FUNCTION_WITH_ARGS( call1.asObject0(), _python_str_plain_BaseDatabaseWrapper, call3.asObject0(), _python_tmp_class_dict.asObject() ) );
            }
            PyObjectTemporary _python_tmp_class( _tmp_python_tmp_class );
            UPDATE_STRING_DICT0( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_BaseDatabaseWrapper, _python_tmp_class.asObject() );
        }
        {
            frame_guard.setLineNumber( 502 );
            PyObjectTemporary _python_tmp_bases( MAKE_TUPLE1( LOOKUP_BUILTIN( _python_str_plain_object ) ) );
            PyObjectTemporary _python_tmp_class_dict( impl_class_2_BaseDatabaseFeatures_of_module_django__db__backends(  ) );
            PyObjectTemporary _python_tmp_metaclass( ( SEQUENCE_CONTAINS_BOOL( _python_str_plain___metaclass__, _python_tmp_class_dict.asObject() ) ? DICT_GET_ITEM( _python_tmp_class_dict.asObject(), _python_str_plain___metaclass__ ) : SELECT_METACLASS( _python_tmp_bases.asObject(), ( _mvar_django__db__backends___metaclass__.isInitialized( false ) ? _mvar_django__db__backends___metaclass__.asObject0() : NULL ) ) ) );
            PyObject *_tmp_python_tmp_class;
            {
                PyObjectTempKeeper0 call5;
                PyObjectTempKeeper0 call7;
                _tmp_python_tmp_class = ( call5.assign( _python_tmp_metaclass.asObject() ), call7.assign( _python_tmp_bases.asObject() ), CALL_FUNCTION_WITH_ARGS( call5.asObject0(), _python_str_plain_BaseDatabaseFeatures, call7.asObject0(), _python_tmp_class_dict.asObject() ) );
            }
            PyObjectTemporary _python_tmp_class( _tmp_python_tmp_class );
            UPDATE_STRING_DICT0( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_BaseDatabaseFeatures, _python_tmp_class.asObject() );
        }
        {
            frame_guard.setLineNumber( 644 );
            PyObjectTemporary _python_tmp_bases( MAKE_TUPLE1( LOOKUP_BUILTIN( _python_str_plain_object ) ) );
            PyObjectTemporary _python_tmp_class_dict( impl_class_3_BaseDatabaseOperations_of_module_django__db__backends(  ) );
            PyObjectTemporary _python_tmp_metaclass( ( SEQUENCE_CONTAINS_BOOL( _python_str_plain___metaclass__, _python_tmp_class_dict.asObject() ) ? DICT_GET_ITEM( _python_tmp_class_dict.asObject(), _python_str_plain___metaclass__ ) : SELECT_METACLASS( _python_tmp_bases.asObject(), ( _mvar_django__db__backends___metaclass__.isInitialized( false ) ? _mvar_django__db__backends___metaclass__.asObject0() : NULL ) ) ) );
            PyObject *_tmp_python_tmp_class;
            {
                PyObjectTempKeeper0 call11;
                PyObjectTempKeeper0 call9;
                _tmp_python_tmp_class = ( call9.assign( _python_tmp_metaclass.asObject() ), call11.assign( _python_tmp_bases.asObject() ), CALL_FUNCTION_WITH_ARGS( call9.asObject0(), _python_str_plain_BaseDatabaseOperations, call11.asObject0(), _python_tmp_class_dict.asObject() ) );
            }
            PyObjectTemporary _python_tmp_class( _tmp_python_tmp_class );
            UPDATE_STRING_DICT0( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_BaseDatabaseOperations, _python_tmp_class.asObject() );
        }
        frame_guard.setLineNumber( 1138 );
        UPDATE_STRING_DICT1( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_FieldInfo, CALL_FUNCTION_WITH_ARGS( _mvar_django__db__backends_namedtuple.asObject0(), _python_str_plain_FieldInfo, _python_str_digest_fff527bc94b1698409f177e91ef39fba ) );
        {
            frame_guard.setLineNumber( 1142 );
            PyObjectTemporary _python_tmp_bases( MAKE_TUPLE1( LOOKUP_BUILTIN( _python_str_plain_object ) ) );
            PyObjectTemporary _python_tmp_class_dict( impl_class_4_BaseDatabaseIntrospection_of_module_django__db__backends(  ) );
            PyObjectTemporary _python_tmp_metaclass( ( SEQUENCE_CONTAINS_BOOL( _python_str_plain___metaclass__, _python_tmp_class_dict.asObject() ) ? DICT_GET_ITEM( _python_tmp_class_dict.asObject(), _python_str_plain___metaclass__ ) : SELECT_METACLASS( _python_tmp_bases.asObject(), ( _mvar_django__db__backends___metaclass__.isInitialized( false ) ? _mvar_django__db__backends___metaclass__.asObject0() : NULL ) ) ) );
            PyObject *_tmp_python_tmp_class;
            {
                PyObjectTempKeeper0 call13;
                PyObjectTempKeeper0 call15;
                _tmp_python_tmp_class = ( call13.assign( _python_tmp_metaclass.asObject() ), call15.assign( _python_tmp_bases.asObject() ), CALL_FUNCTION_WITH_ARGS( call13.asObject0(), _python_str_plain_BaseDatabaseIntrospection, call15.asObject0(), _python_tmp_class_dict.asObject() ) );
            }
            PyObjectTemporary _python_tmp_class( _tmp_python_tmp_class );
            UPDATE_STRING_DICT0( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_BaseDatabaseIntrospection, _python_tmp_class.asObject() );
        }
        {
            frame_guard.setLineNumber( 1282 );
            PyObjectTemporary _python_tmp_bases( MAKE_TUPLE1( LOOKUP_BUILTIN( _python_str_plain_object ) ) );
            PyObjectTemporary _python_tmp_class_dict( impl_class_5_BaseDatabaseClient_of_module_django__db__backends(  ) );
            PyObjectTemporary _python_tmp_metaclass( ( SEQUENCE_CONTAINS_BOOL( _python_str_plain___metaclass__, _python_tmp_class_dict.asObject() ) ? DICT_GET_ITEM( _python_tmp_class_dict.asObject(), _python_str_plain___metaclass__ ) : SELECT_METACLASS( _python_tmp_bases.asObject(), ( _mvar_django__db__backends___metaclass__.isInitialized( false ) ? _mvar_django__db__backends___metaclass__.asObject0() : NULL ) ) ) );
            PyObject *_tmp_python_tmp_class;
            {
                PyObjectTempKeeper0 call17;
                PyObjectTempKeeper0 call19;
                _tmp_python_tmp_class = ( call17.assign( _python_tmp_metaclass.asObject() ), call19.assign( _python_tmp_bases.asObject() ), CALL_FUNCTION_WITH_ARGS( call17.asObject0(), _python_str_plain_BaseDatabaseClient, call19.asObject0(), _python_tmp_class_dict.asObject() ) );
            }
            PyObjectTemporary _python_tmp_class( _tmp_python_tmp_class );
            UPDATE_STRING_DICT0( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_BaseDatabaseClient, _python_tmp_class.asObject() );
        }
        {
            frame_guard.setLineNumber( 1299 );
            PyObjectTemporary _python_tmp_bases( MAKE_TUPLE1( LOOKUP_BUILTIN( _python_str_plain_object ) ) );
            PyObjectTemporary _python_tmp_class_dict( impl_class_6_BaseDatabaseValidation_of_module_django__db__backends(  ) );
            PyObjectTemporary _python_tmp_metaclass( ( SEQUENCE_CONTAINS_BOOL( _python_str_plain___metaclass__, _python_tmp_class_dict.asObject() ) ? DICT_GET_ITEM( _python_tmp_class_dict.asObject(), _python_str_plain___metaclass__ ) : SELECT_METACLASS( _python_tmp_bases.asObject(), ( _mvar_django__db__backends___metaclass__.isInitialized( false ) ? _mvar_django__db__backends___metaclass__.asObject0() : NULL ) ) ) );
            PyObject *_tmp_python_tmp_class;
            {
                PyObjectTempKeeper0 call21;
                PyObjectTempKeeper0 call23;
                _tmp_python_tmp_class = ( call21.assign( _python_tmp_metaclass.asObject() ), call23.assign( _python_tmp_bases.asObject() ), CALL_FUNCTION_WITH_ARGS( call21.asObject0(), _python_str_plain_BaseDatabaseValidation, call23.asObject0(), _python_tmp_class_dict.asObject() ) );
            }
            PyObjectTemporary _python_tmp_class( _tmp_python_tmp_class );
            UPDATE_STRING_DICT0( _moduledict_django__db__backends, (Nuitka_StringObject *)_python_str_plain_BaseDatabaseValidation, _python_tmp_class.asObject() );
        }
    }
    catch ( PythonException &_exception )
    {
        if ( !_exception.hasTraceback() )
        {
            _exception.setTraceback( MAKE_TRACEBACK( frame_guard.getFrame() ) );
        }
        else
        {
            _exception.addTraceback( frame_guard.getFrame0() );
        }

#if 0
    // TODO: Recognize the need for it
        Py_XDECREF( frame_guard.getFrame0()->f_locals );
        frame_guard.getFrame0()->f_locals = INCREASE_REFCOUNT( ((PyModuleObject *)_module_django__db__backends)->md_dict );
#endif

    // Return the error.
        _exception.toPython();
        return MOD_RETURN_VALUE( NULL );
    }

   return MOD_RETURN_VALUE( _module_django__db__backends );
}
